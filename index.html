<!DOCTYPE html>
<html lang="en">
<head>
    <title>Jungel</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link rel="stylesheet" href="style.css">
</head>
<body>

<div id="container"><br /><br /><br /><br /><br />Generating world...</div>
<div id="info"><a href="http://threejs.org" target="_blank">three.js</a> - webgl terrain demo<br />(left click: forward, right click: backward)</div>

<script src="bower_components/three.js/build/three.min.js"></script>
<script src="bower_components/three.js/build/three.js"></script>
<script src="bower_components/three.js/examples/js/loaders/OBJLoader.js"></script>
<script src="bower_components/three.js/examples/js/loaders/DDSLoader.js"></script>
<script src="bower_components/three.js/examples/js/loaders/MTLLoader.js"></script>
<script src="bower_components/three.js/examples/js/loaders/OBJMTLLoader.js"></script>
<script src="bower_components/three.js/examples/js/controls/FirstPersonControls.js"></script>
<script src="bower_components/three.js/examples/js/controls/OrbitControls.js"></script>
<script src="bower_components/three.js/examples/js/ImprovedNoise.js"></script>
<script src="bower_components/three.js/examples/js/Detector.js"></script>
<script src="bower_components/three.js/examples/js/libs/stats.min.js"></script>
<script src="bower_components/three.js/examples/js/libs/dat.gui.min.js"></script>
<script src="bower_components/three.js/examples/js/objects/ShadowMesh.js"></script>
<script src="bower_components/three.js/examples/js/postprocessing/BloomPass.js"></script>

<script src="src/HeightMapGeometry.js"></script>
<script src="src/HeightMapMesh.js"></script>
<script src="src/DayNightCycle.js"></script>
<script src="src/GenerateMap.js"></script>
<script src="src/GenerateObjects.js"></script>
<script src="src/GenerateTexture.js"></script>
<script src="src/Mirror.js"></script> 
<script src="src/Water.js"></script>

<script id="instanced-vshader" type="x-shader/x-vertex">
		// Other attributes and uniforms are supposed to be filled in by Three.js
		// To avoid it being filled in automatically, use RawShaderMaterial

        // Instanced attribute, updated only when a new instance is drawn (ie. when all vertices have been drawn and
        // we're going to draw a slightly different one.
		attribute vec3 translate;

		varying vec2 vUV;

		void main() {

			<!--vec4 mvPosition = modelViewMatrix * vec4( translate + position, 1.0 );-->
            vec4 pos = vec4(position, 1.0);
			vUV = uv;

			gl_Position = projectionMatrix * modelViewMatrix * pos;

		}

</script>

<script id="fshader" type="x-shader/x-fragment">
        // Other attributes and uniforms are supposed to be filled in by Three.js
		// To avoid it being filled in automatically, use RawShaderMaterial

           uniform sampler2D texture;
           varying vec2 vUV;
           <!--uniform vec3 color;-->

		void main() {
            vec4 sample = texture2D(texture, vUV);
			gl_FragColor = vec4(sample.xyz, sample.w);

		}
</script>

<script>
    // What is this, do we need it?
    if ( ! Detector.webgl ) {
        Detector.addGetWebGLMessage();
        document.getElementById( 'container' ).innerHTML = "";
    }

    var container, stats, gui;

    var camera, controls, scene, renderer, composer;

    var x, y, z;
    var x2, y2, z2;
    var flag = false;
    // Probably GenerateMap
    var groundData, groundMesh, groundTexture, groundMapImage, groundGeometry,
            mountainData, mountainMesh, mountainTexture, mountainMapImage, mountainGeometry,
            lavaMesh, lavaTexture,lavaGeometry,
            beachData, beachMesh, beachTexture, beachMapImage, beachGeometry;

    var water; 
    var waterMesh;
    var sunLight;
    var frameTime;
    var angle = 0.0;

    var urlPrefix;
    var urls;
    var textureCube;
    var shader;
    var skyBoxMaterial;
    var mat;
    var skyBox;

    var randomPoints;
    var randx;
    var randy;
    var randz;
    var bbox;

    var manager;
    var loader;
    var objectMaterialLoader;

    var lensFlare;
    var flareColor;
    var textureFlare0;

    var objectLoader;
    var models;
    var j;

    var spriteModels;
    var spriteGeom;
    var spriteTexture;
    var palmSprite;
    var myPalm;

    var waterLevel;

    var waterNormals;
    var count;
    var splineCurve;
    var splineGeometry;
    var irregularMaterial;
    var splineCurveObject;
    var boxGeom;
    var customBox;
    var customBox2;
    var numBoxes;
    var center;
    var radius;
    var instancedMaterial;
    var instancedBox;
    var instancedBoxGeom;
    // WAAAAAY too many var stuff here. Move it where it belongs (GenerateTexture for the most part)
    /*Ground texture*/

      /*Palm texture*/
    var palmTexture;
    var plantTexture;
    var shipTexture;

    var worldWidth, worldHeight ,
            worldHalfWidth, worldHalfHeight;

    var clock = new THREE.Clock();

    window.onload = function() {
        init();
        animate();
    };

    var parameters = { 
        width: 2000, 
        height: 2000, 
        widthSegments: 250, 
        heightSegments: 250, 
        depth: 1500, 
        param: 4, 
        filterparam: 1 
    };

    function init() {
        "use strict";

        container = document.getElementById('container');

/*        gui = new DAT.GUI({
            height : 5 * 32 - 1
        });

        var params = {
            x:0,
            y:0
        };

        gui.add(params, 'interation');*/

        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 300000);
        camera.name = 'camera';

        scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0XFFFFFF, 0.0000085);

        controls = new THREE.FirstPersonControls(camera);
        controls.movementSpeed = 1500;
        controls.lookSpeed = 0.1;

        manager = new THREE.LoadingManager();
        manager.onProgress = function ( item, loaded, total ) {

            console.log( item, loaded, total );
        };

        loader = new THREE.ImageLoader( manager );

        ///////////////////////////////////////////////////////
        //                      Renderer                    //
        /////////////////////////////////////////////////////
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true } );
        renderer.setClearColor( 0xbfd1e5 );
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( window.innerWidth, window.innerHeight );
        renderer.autoClear = false;

        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.shadowDarkness = 1.0;
        container.innerHTML = "";

        container.appendChild( renderer.domElement );

        stats = new Stats();
        stats.domElement.style.position = 'absolute';
        stats.domElement.style.top = '0px';
        container.appendChild( stats.domElement );

        ///////////////////////////////////////////////////////
        //                      Lights                      //
        /////////////////////////////////////////////////////

        // Needed for materials using phong shading
        // This needs to be done differently
        var ambientLight = new THREE.AmbientLight(0xffffff);
        ambientLight.name = 'ambientLight';
        scene.add(ambientLight);

        sunLight = new DayNightCycle.sunLight();

        sunLight.name = 'sun';
        sunLight.object3d.position.set(10000, 10000, 10000);

        sunLight.object3d.castShadow = true;
        //sunLight.object3d.shadowCameraVisible = true;

        sunLight.object3d.castShadow = true;

        sunLight.object3d.shadowMapWidth = 512;
        sunLight.object3d.shadowMapHeight = 512;

        //directionalLight.shadowCameraNear = 5;
        sunLight.object3d.shadowCameraFar = 10000;
        //directionalLight.shadowCameraFov = 360;

        var d = 15000;
        sunLight.object3d.shadowCameraRight = d;
        sunLight.object3d.shadowCameraLeft = -d;
        sunLight.object3d.shadowCameraTop = d;
        sunLight.object3d.shadowCameraBottom = -d;

        sunLight.object3d.shadowDarkness = 0.5;

        sunLight.shadowCameraVisible = true;

        scene.add( sunLight.object3d );
        scene.add(new THREE.DirectionalLightHelper(sunLight.object3d, 100));

        textureFlare0 = THREE.ImageUtils.loadTexture("textures/solarFlare.png");
        textureFlare0.transparent = true;
        textureFlare0.opacity = 1.0;
        textureFlare0.minFilter = THREE.LinearMipMapLinearFilter;

        flareColor = new THREE.Color(0xffaacc);
        lensFlare = new THREE.LensFlare(textureFlare0, 350, 0.0, THREE.AdditiveBlending, flareColor);

        lensFlare.add(textureFlare0, 60, 0.6, THREE.AdditiveBlending);
        lensFlare.add(textureFlare0, 70, 0.7, THREE.AdditiveBlending);
        lensFlare.add(textureFlare0, 120, 0.9, THREE.AdditiveBlending);
        lensFlare.add(textureFlare0, 70, 1.0, THREE.AdditiveBlending);

        lensFlare.position.set(sunLight.object3d.position.x, sunLight.object3d.position.y, sunLight.object3d.position.z);
        //lensFlare.position.set(10000, 20000, 20000);
        //lensFlare.position = sunLight.object3d.position;

        scene.add(lensFlare);

        // Height map generation/extraction
        // Needs to move to GenerateMap
        //

        ///////BLOOOM
/*        var renderModel = new THREE.RenderPass( scene, camera );
        var effectBloom = new THREE.BloomPass( 1.25 );
        var effectFilm = new THREE.FilmPass( 0.35, 0.95, 2048, false );
        effectFilm.renderToScreen = true;
        composer = new THREE.EffectComposer( renderer );
        composer.addPass( renderModel );
        composer.addPass( effectBloom );
        composer.addPass( effectFilm );*/
        ////




        ///////////////////////////////////////////////////////
        //                      Meshes                      //
        /////////////////////////////////////////////////////

        //
        // This need to move to GenerateMap
        //

        //Ground
        groundMapImage = document.getElementById('groundmap');
        groundData = GenerateMap.getPixelValues(groundMapImage, 'r');

        worldWidth = groundMapImage.width;
        worldHeight = groundMapImage.height;
        worldHalfWidth = Math.floor(worldWidth / 2);
        worldHalfHeight = Math.floor(worldHeight / 2);

        groundGeometry = new HeightMapBufferGeometry(groundData, worldWidth, worldHeight);
        groundGeometry.scale(50*worldWidth, 4500, 50*worldHeight);

        groundTexture = THREE.ImageUtils.loadTexture( "textures/groundDirtTexture.jpg" );
        groundTexture.wrapS = groundTexture.wrapT = THREE.RepeatWrapping;
        groundTexture.repeat.set( 256, 256 );
        groundTexture.magFilter = THREE.NearestFilter;
        groundTexture.minFilter = THREE.LinearMipMapLinearFilter;

        groundMesh = new HeightMapMesh( groundGeometry,  new THREE.MeshLambertMaterial( { map: groundTexture } ));
        groundMesh.name = "terrain";
        groundMesh.receiveShadows = true;
        scene.add( groundMesh );

        //Mountain
        mountainMapImage = document.getElementById('mountainmap');
        mountainData = GenerateMap.getPixelValues(mountainMapImage, 'r');

        mountainGeometry = new HeightMapBufferGeometry(mountainData, worldWidth, worldHeight);
        mountainGeometry.scale(50*worldWidth, 4500, 50*worldHeight);

        mountainTexture = THREE.ImageUtils.loadTexture( "textures/mountainTexture.jpg" );
        mountainTexture.wrapS = mountainTexture.wrapT = THREE.RepeatWrapping;
        mountainTexture.repeat.set( 64, 64 );
        mountainTexture.magFilter = THREE.NearestFilter;
        mountainTexture.minFilter = THREE.LinearMipMapLinearFilter;

        mountainMesh = new HeightMapMesh( mountainGeometry, new THREE.MeshLambertMaterial( { map: mountainTexture } ) );
        mountainMesh.name = "mountain";
        groundMesh.add(mountainMesh);

        //Lava
        lavaTexture = THREE.ImageUtils.loadTexture( "textures/lavaTexture.jpg" );
        lavaTexture.wrapS = lavaTexture.wrapT = THREE.RepeatWrapping;
/*        lavaTexture.repeat.set( 64, 64 );*/

        lavaGeometry = new THREE.CircleGeometry(700, 1000);
        lavaMesh = new THREE.Mesh(lavaGeometry,new THREE.MeshLambertMaterial({side: THREE.DoubleSide, map: lavaTexture}));

        lavaMesh.position.set(2457, 3118, -7502);
        lavaMesh.rotation.x = Math.PI /2;
        scene.add(lavaMesh);


        /*var lavaBubbleGeom = new THREE.SphereGeometry(100, 1000, 1000);
        var lavaBubbleMesh = new THREE.Mesh(lavaBubbleGeom, new THREE.MeshLambertMaterial({map: lavaTexture}));

        lavaBubbleMesh.scale(10,10,10);
        lavaMesh.position.set(2457, 3118, -7502);
        scene.add(lavaBubbleMesh);*/

        //Beach
        beachMapImage = document.getElementById('beachmap');
        beachData = GenerateMap.getPixelValues(beachMapImage, 'r');

        beachGeometry = new HeightMapBufferGeometry(beachData, worldWidth, worldHeight);
        beachGeometry.scale(50*worldWidth, 4500, 50*worldHeight);

        beachTexture = THREE.ImageUtils.loadTexture( "textures/beachTexture.jpg" );
        beachTexture.wrapS = beachTexture.wrapT = THREE.RepeatWrapping;
        beachTexture.repeat.set( 64, 64 );
        beachTexture.magFilter = THREE.NearestFilter;
        beachTexture.minFilter = THREE.LinearMipMapLinearFilter;

        beachMesh = new HeightMapMesh( beachGeometry, new THREE.MeshLambertMaterial( { map: beachTexture } ) );
        beachMesh.name = "beach";
        groundMesh.add(beachMesh);

        //Water

        waterNormals = new THREE.ImageUtils.loadTexture( 'textures/waternormals.jpg' );
        waterNormals.wrapS = waterNormals.wrapT = THREE.RepeatWrapping;


        water = new THREE.Water( renderer, camera, scene, {
            textureWidth: 512,
            textureHeight: 512,
            waterNormals: waterNormals,
            alpha: 	1.0,
            sunDirection:  ambientLight.position.clone().normalize(),
            sunColor: 0xffffff,
            waterColor: 0x001e0f,
            distortionScale: 50.0,
        } );
        waterMesh = new THREE.Mesh(
                new THREE.PlaneBufferGeometry(parameters.width * 500, parameters.height * 500 ),
                water.material
        );

        water.opacity = 0.5;
        waterMesh.add( water );
        waterMesh.rotation.x = - Math.PI * 0.5;
        waterMesh.position.y += 70;
        scene.add( waterMesh );

        waterLevel = waterMesh.position.y;

        // AUDIO
        var listener = new THREE.AudioListener();
        scene.add(listener);
        var audio = new THREE.Audio(listener);
        audio.load('audio/rainforest.mp3');
        //audio.autoplay = true;
        audio.setLoop(500);
        scene.add(audio);

        /////////////SKYBOX
        urlPrefix = 'textures/';
        urls = [ urlPrefix + 'sea_negx.jpg',
            urlPrefix + 'sea_neutral.jpg',
            urlPrefix + 'sea_negy.jpg',
            urlPrefix + 'sea_posy.jpg',
            urlPrefix + 'sea_negz.jpg',
            urlPrefix + 'sea_posz.jpg' ];


        textureCube = THREE.ImageUtils.loadTextureCube(urls);
        textureCube.format = THREE.RGBFormat;


        shader = THREE.ShaderLib['cube']; // init cube shader from built-in lib
        shader.uniforms['tCube'].value = textureCube; // apply textures to shader


        // create shader material
        skyBoxMaterial = new THREE.ShaderMaterial({
            fragmentShader : shader.fragmentShader,
            vertexShader : shader.vertexShader,
            uniforms : shader.uniforms,
            depthWrite : false,
            side : THREE.BackSide
        });


        mat = new THREE.MeshBasicMaterial({envMap : textureCube, side: THREE.BackSide});

        // create skybox mesh
        skyBox = new THREE.Mesh(new THREE.BoxGeometry(300000, 400000, 300000), mat);
        skyBox.doubleSided = true;


        groundMesh.add(skyBox);

        /*Irregulaert formet spline-kurve*/
        // Move this to MovementAndCamera and make it work!
        randomPoints = [];

        /*
        var num = 10;

        for(var i = 0; i < num; i++) {
            randomPoints.push(new THREE.Vector3(Math.random() * 4000 - 1500, Math.random()
                    * 3000 - 1500, Math.random() * 3000 - 1500));
        }

        for(var i = 0; i < num; i++) {
            randomPoints[i].y = terrainMesh.getHeightAtPoint(randomPoints[i]) + 1;
        }

        var negate = -2;
         */


                count = 1000;

        randomPoints.push(
                new THREE.Vector3(-1000, 1000, 1000),
                new THREE.Vector3(-800, 1000, 900),
                new THREE.Vector3(-400, 1000, 800),
                new THREE.Vector3(200, 1000, 700),
                new THREE.Vector3(400, 1000, 400),
                new THREE.Vector3(600, 1000, -200),
                new THREE.Vector3(500, 1000, -600),
                new THREE.Vector3(900, 1000, - 1400),
                new THREE.Vector3(1300, 1000, -1400),
                new THREE.Vector3(1600, 1000, -1000),
        new THREE.Vector3(1600, 1000, -900),
        new THREE.Vector3(1500, 1000, -800),
        new THREE.Vector3(1300, 1000, -700),
        new THREE.Vector3(900, 1000, -700)
        );

        for(var i = 0; i < 14; i++) {
            randomPoints[i].y = groundMesh.getHeightAtPoint(randomPoints[i]);

           /* if(randomPoints[i].y < terrainMesh.getHeightAtPoint(randomPoints[i])) {
             randomPoints[i].y += 10;
             }*/
        }


        splineCurve = new THREE.CatmullRomCurve3(randomPoints);

        splineGeometry = new THREE.Geometry();
        splineGeometry.vertices = splineCurve.getPoints(2000);

        /*  for(var i = 0; i < 1000; i++) {
            geometry.vertices[i].y = terrainMesh.getHeightAtPoint(geometry.vertices[i]);
        }   */


        irregularMaterial = new THREE.LineBasicMaterial( {color: 0x0000ff} );

        splineCurveObject = new THREE.Line(splineGeometry, irregularMaterial);
        scene.add(splineCurveObject);

        splineCurveObject.position.set(1000,100,1000);

        //Old camera position, approximately in the middle of the map.
/*        camera.position.y = terrainMesh.getHeightAtPoint(camera.position) + 500;*/

        //New camera position, on the "southern" side of the map
        camera.position.x = -6000;
        camera.position.z = 6900;
        camera.position.y = groundMesh.getHeightAtPoint(camera.position) + 350;

        boxGeom = new THREE.BoxGeometry(100, 100, 100);
        customBox = new THREE.Mesh(boxGeom);

        groundMesh.add(customBox);
        //customBox.position.setY(groundMesh.getHeightAtPoint(customBox.position));

        customBox2 = new THREE.Mesh(boxGeom);
        customBox2.position.x = -4900;
        customBox2.position.z = 3900;

        groundMesh.add(customBox2);
       customBox2.position.setY(groundMesh.getHeightAtPoint(customBox2.position)) ;

        //
        // Generate random positions for some number of boxes
        // Used in instancing. Better examples:
        //  * http://threejs.org/examples/#webgl_buffergeometry_instancing_dynamic
        //  * http://threejs.org/examples/#webgl_buffergeometry_instancing_billboards
        //

        // Make a buffer that can use instanced attributes
        instancedBoxGeom = new THREE.InstancedBufferGeometry();
        // Copy geometry from a standard box.
        instancedBoxGeom.fromGeometry(new THREE.BoxGeometry(100, 100, 100));

        numBoxes = 10;
        center = new THREE.Vector3(0,0,0);
        radius = 50 * worldHalfWidth;

        palmTexture = new THREE.Texture();
        palmTexture.wrapS = palmTexture.wrapT = THREE.RepeatWrapping;
        plantTexture = new THREE.Texture();
        shipTexture = new THREE.Texture();

        GenerateObjects.billboard();
        /*GenerateObjects.palms2D();*/
        /*GenerateObjects.palms3D();*/

        GenerateObjects.palms3D(customBox, 10, 1000);

        GenerateObjects.palms3D(customBox2, 20, 1000);

        GenerateObjects.plants3D();
        GenerateObjects.ship();


        instancedMaterial = new THREE.ShaderMaterial( {
            uniforms: {
                color: { type: "c" , value: new THREE.Color(Math.random(), Math.random(), Math.random()) }
            },
            vertexShader: document.getElementById("instanced-vshader").textContent,
            fragmentShader: document.getElementById("fshader").textContent
        } );

        instancedBox = new THREE.Mesh(instancedBoxGeom, instancedMaterial);
        instancedBox.name = "instancedBox";


        window.addEventListener( 'resize', onWindowResize, false );
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize( window.innerWidth, window.innerHeight );
        controls.handleResize();
    }

    // Seen both animate and render functions done in a different way thight might be better for us
    // Should change it
    function animate() {

        requestAnimationFrame( animate );  
        angle +=0.00001; 
        //sunLight.update(angle); 
        water.material.uniforms.time.value += angle; 
        lensFlare.position.set(sunLight.object3d.position.x, sunLight.object3d.position.y, sunLight.object3d.position.z);

        lavaMesh.rotation.z += 0.01;
        x = camera.position.x;
        y = camera.position.y;
        z = camera.position.z;

        if((x2 === x) && (y2 === y) && (z2 === z) ) {
            flag = false;
        } else {
            flag = true;
        }

        if(flag) {
            console.log(Math.round(x), Math.round(y), Math.round(z) );
        }

        render(); 
        stats.update();

    }

    function render() {
        //        renderer.clear(); //nullstiller alle fargebuffere etc 
        controls.update(clock.getDelta());
          //        controls.update(); 
        x2 = x;
        y2 = y;
        z2 = z;
        water.render(); 
        renderer.render( scene, camera ); 
    }

    // Do we use onProgress and onError
    // Do we need it
    function onProgress( xhr ) {
        if ( xhr.lengthComputable ) {
            var percentComplete = xhr.loaded / xhr.total * 100;
            console.log( Math.round(percentComplete, 2) + '% downloaded' );
        }
    }

    function onError( xhr ) {}

 </script>

<img src="textures/groundMap.jpeg" id="groundmap" hidden/>
<img src="textures/mountainMap.jpeg" id="mountainmap" hidden/>
<img src="textures/beachMap.jpeg" id="beachmap" hidden/>

</body>
</html>