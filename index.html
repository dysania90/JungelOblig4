<!DOCTYPE html>
<html lang="en">
<head>
    <title>Jungel</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link rel="stylesheet" href="style.css">
</head>
<body>

<div id="container"><br /><br /><br /><br /><br />Generating world...</div>
<div id="info"><a href="http://threejs.org" target="_blank">three.js</a> - webgl terrain demo<br />(left click: forward, right click: backward)</div>

<script src="bower_components/three.js/build/three.min.js"></script>
<script src="bower_components/three.js/build/three.js"></script>
<script src="bower_components/three.js/examples/js/loaders/OBJLoader.js"></script>

<script src="bower_components/three.js/examples/js/loaders/DDSLoader.js"></script>
<script src="bower_components/three.js/examples/js/loaders/MTLLoader.js"></script>
<script src="bower_components/three.js/examples/js/loaders/OBJMTLLoader.js"></script>

<script src="bower_components/three.js/examples/js/controls/FirstPersonControls.js"></script>

<script src="bower_components/three.js/examples/js/ImprovedNoise.js"></script>
<script src="bower_components/three.js/examples/js/Detector.js"></script>
<script src="bower_components/three.js/examples/js/libs/stats.min.js"></script>

<script src="bower_components/three.js/examples/js/objects/ShadowMesh.js"></script>

<script src="src/HeightMapGeometry.js"></script>
<script src="src/HeightMapMesh.js"></script>
<script src="src/DayNightCycle.js"></script>
<script src="src/GenerateMap.js"></script>
<script src="src/GenerateObjects.js"></script>
<script src="src/GenerateTexture.js"></script>


<script id="instanced-vshader" type="x-shader/x-vertex">
		// Other attributes and uniforms are supposed to be filled in by Three.js
		// To avoid it being filled in automatically, use RawShaderMaterial

        // Instanced attribute, updated only when a new instance is drawn (ie. when all vertices have been drawn and
        // we're going to draw a slightly different one.
		attribute vec3 translate;

		varying vec2 vUv;

		void main() {

			vec4 mvPosition = modelViewMatrix * vec4( translate + position, 1.0 );

			vUv = uv;

			gl_Position = projectionMatrix * mvPosition;

		}

</script>

<script id="fshader" type="x-shader/x-fragment">
        // Other attributes and uniforms are supposed to be filled in by Three.js
		// To avoid it being filled in automatically, use RawShaderMaterial

           uniform vec3 color;

		void main() {

			gl_FragColor = vec4(color, 1.0);

		}
</script>

<script>
    // What is this, do we need it?
    if ( ! Detector.webgl ) {
        Detector.addGetWebGLMessage();
        document.getElementById( 'container' ).innerHTML = "";
    }

    var container, stats;

    var camera, controls, scene, renderer;

    // Probably GenerateMap
    var groundData, groundMesh, groundTexture,
            mountainData, mountainMesh, mountainTexture,
            lavaData, lavaMesh, lavaTexture,
            roadData, roadMesh, roadTexture,
            waterMesh, waterData;

    var sunLight;
    var frameTime;
    var angle = 0.0;

    var lensFlare;
    var flareColor;
    var textureFlare0;

    var objectLoader;
    var models;
    var j;

    var spritemodels;
    var spriteGeom;
    var spriteTexture;
    var palmSprite;
    var myPalm;

    // WAAAAAY too many var stuff here. Move it where it belongs (GenerateTexture for the most part)
    /*Ground texture*/
    var groundtexture = THREE.ImageUtils.loadTexture( "textures/junglefloortexture.jpg" );
    groundtexture.wrapS = THREE.RepeatWrapping;
    groundtexture.wrapT = THREE.RepeatWrapping;
    groundtexture.repeat.set( 256, 256 );

    var mountaintexture = THREE.ImageUtils.loadTexture( "textures/mountaintexture.jpg" );
    mountaintexture.minFilter = THREE.NearestFilter;
    groundtexture.wrapS = THREE.RepeatWrapping;
    groundtexture.wrapT = THREE.RepeatWrapping;
    /*groundtexture.repeat.set( 32, 32 );*/

    var lavatexture = THREE.ImageUtils.loadTexture( "textures/lavatexture.jpg" );
    lavatexture.wrapS = THREE.RepeatWrapping;
    lavatexture.wrapT = THREE.RepeatWrapping;
    lavatexture.repeat.set( 64, 64);

    /*Dirt road texture*/
    var dirtroadtexture = THREE.ImageUtils.loadTexture("textures/dirtroadtexture.jpg");
    dirtroadtexture.wrapS = THREE.RepeatWrapping;
    dirtroadtexture.wrapT = THREE.RepeatWrapping;
    dirtroadtexture.repeat.set( 64, 64 );

    /*Water texture*/
    var watertexture = THREE.ImageUtils.loadTexture("textures/watertexture.jpg");
    watertexture.wrapS = THREE.RepeatWrapping;
    watertexture.wrapT = THREE.RepeatWrapping;
    watertexture.repeat.set( 64, 64 );

    /*Palm texture*/
    var texture;

    var worldWidth = 512, worldDepth = 512,
            worldHalfWidth = worldWidth / 2, worldHalfDepth = worldDepth / 2;

    var clock = new THREE.Clock();

    window.onload = function() {
        init();
        animate();
    };

    function init() {
        "use strict";

        container = document.getElementById('container');

        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 20000);
        camera.name = 'camera';

        scene = new THREE.Scene();

        controls = new THREE.FirstPersonControls(camera);
        controls.movementSpeed = 1000;
        controls.lookSpeed = 0.1;

        ///////////////////////////////////////////////////////
        //                      Lights                      //
        /////////////////////////////////////////////////////

        // Needed for materials using phong shading
        // This needs to be done differently
        var ambientLight = new THREE.AmbientLight(0xffffff);
        ambientLight.name = 'ambientLight';
        scene.add(ambientLight);

        sunLight = new DayNightCycle.sunLight();

        sunLight.name = 'sun';
        sunLight.object3d.position.set(10000, 10000, 10000);

        sunLight.object3d.castShadow = true;
        //sunLight.object3d.shadowCameraVisible = true;

        sunLight.object3d.castShadow = true;

        sunLight.object3d.shadowMapWidth = 512;
        sunLight.object3d.shadowMapHeight = 512;

        //directionalLight.shadowCameraNear = 5;
        sunLight.object3d.shadowCameraFar = 10000;
        //directionalLight.shadowCameraFov = 360;

        var d = 15000;
        sunLight.object3d.shadowCameraRight = d;
        sunLight.object3d.shadowCameraLeft = -d;
        sunLight.object3d.shadowCameraTop = d;
        sunLight.object3d.shadowCameraBottom = -d;

        sunLight.object3d.shadowDarkness = 0.5;

        sunLight.shadowCameraVisible = true;


        scene.add( sunLight.object3d );
        scene.add(new THREE.DirectionalLightHelper(sunLight.object3d, 100));


        textureFlare0 = THREE.ImageUtils.loadTexture("textures/solarFlare.png");
        textureFlare0.transparent = true;
        textureFlare0.opacity = 1.0;
        textureFlare0.minFilter = THREE.NearestFilter;

        flareColor = new THREE.Color(0xffaacc);
        lensFlare = new THREE.LensFlare(textureFlare0, 350, 0.0, THREE.AdditiveBlending, flareColor);

        lensFlare.add(textureFlare0, 60, 0.6, THREE.AdditiveBlending);
        lensFlare.add(textureFlare0, 70, 0.7, THREE.AdditiveBlending);
        lensFlare.add(textureFlare0, 120, 0.9, THREE.AdditiveBlending);
        lensFlare.add(textureFlare0, 70, 1.0, THREE.AdditiveBlending);

        lensFlare.position.set(sunLight.object3d.position.x, sunLight.object3d.position.y, sunLight.object3d.position.z);
        //lensFlare.position.set(10000, 20000, 20000);
        //lensFlare.position = sunLight.object3d.position;

        scene.add(lensFlare);

        // Height map generation/extraction
        // Needs to move to GenerateMap
        //

        var useRandomHeightMap = false;

        if (useRandomHeightMap) {
            groundData = GenerateMap.generateHeight( worldWidth, worldDepth );
        } else {
            var groundImage = document.getElementById('groundmap');
            groundData = GenerateMap.getPixelValues(groundImage, 'r');
            worldWidth = groundImage.width;
            worldDepth = groundImage.height;
            worldHalfWidth = Math.floor(worldWidth / 2);
            worldHalfDepth = Math.floor(worldDepth / 2);
        }

        var mountainMapImage = document.getElementById('mountainmap');
        mountainData = GenerateMap.getPixelValues(mountainMapImage, 'r');

        var lavaMapImage = document.getElementById('lavamap');
        lavaData = GenerateMap.getPixelValues(lavaMapImage, 'r');

        var waterMapImage = document.getElementById('watermap');
        waterData = GenerateMap.getPixelValues(waterMapImage, 'r');

        var roadMapImage = document.getElementById('roadheightmap');
        roadData = GenerateMap.getPixelValues(roadMapImage, 'r');
        // Not required to use the generated texture
        // Where do we generate textures? Seems to be spread out. Needs to clump it together and
        // move to own file (GenerateTexture)
/*        terrainTexture = new THREE.CanvasTexture( GenerateTexture.generateTexture( terrainData, worldWidth, worldDepth ) );
        terrainTexture.wrapS = THREE.ClampToEdgeWrapping;
        terrainTexture.wrapT = THREE.ClampToEdgeWrapping;*/

        //
        // Generate terrain geometry and mesh
        // This need to move to GenerateMap
        //


        var groundGeometry = new HeightMapBufferGeometry(groundData, worldWidth, worldDepth);
        // We scale the geometry to avoid scaling the node, since scales propagate.
        groundGeometry.scale(50*worldWidth, 4500, 50*worldDepth);

        var groundMaterial = new THREE.MeshLambertMaterial( { map: groundtexture } );

        groundMesh = new HeightMapMesh( groundGeometry,  groundMaterial);
        groundMesh.name = "terrain";
        groundMesh.receiveShadows = true;
        scene.add( groundMesh );

        var mountainGeometry = new HeightMapBufferGeometry(mountainData, worldWidth, worldDepth);
        mountainGeometry.scale(50*worldWidth, 4500, 50*worldDepth);

        mountainMesh = new HeightMapMesh( mountainGeometry, new THREE.MeshLambertMaterial( { map: mountaintexture } ) );
        mountainMesh.name = "mountain";
        scene.add(mountainMesh);

        var lavaGeometry = new HeightMapBufferGeometry(lavaData, worldWidth, worldDepth);
        lavaGeometry.scale(50*worldWidth, 4500, 50*worldDepth);

        lavaMesh = new HeightMapMesh( lavaGeometry, new THREE.MeshBasicMaterial( { map: lavatexture } ) );
        lavaMesh.name = "lava";
        scene.add(lavaMesh);

        var roadGeometry = new HeightMapBufferGeometry(roadData, worldWidth, worldDepth);
        roadGeometry.scale(50*worldWidth, 4500, 50*worldDepth);

        roadMesh = new HeightMapMesh( roadGeometry, new THREE.MeshLambertMaterial( { map: dirtroadtexture } ) );
        roadMesh.name = "dirtroad";
        scene.add(roadMesh);

        var waterGeometry = new HeightMapBufferGeometry(waterData, worldWidth, worldDepth);
        waterGeometry.scale(50*worldWidth, 1000, 50*worldDepth);

        waterMesh = new HeightMapMesh(waterGeometry, new THREE.MeshLambertMaterial({ map: watertexture}));
        waterMesh.name = "water";

        waterMesh.recieveShadows = true;

        scene.add(waterMesh);
        waterMesh.position.y -= 976;
        var waterLevel = waterMesh.position.y + 976;



        /*Irregulaert formet spline-kurve*/
        // Move this to MovementAndCamera and make it work!
        var randomPoints = [];

        /*
        var num = 10;

        for(var i = 0; i < num; i++) {
            randomPoints.push(new THREE.Vector3(Math.random() * 4000 - 1500, Math.random()
                    * 3000 - 1500, Math.random() * 3000 - 1500));
        }

        for(var i = 0; i < num; i++) {
            randomPoints[i].y = terrainMesh.getHeightAtPoint(randomPoints[i]) + 1;
        }

        var negate = -2;
         */

        var count = 1000;
        /*
        for(var i = 0; i < count; i++) {
            randomPoints.push(new THREE.Vector3(-count+(i*2), 1000, count-(i*7)));
        }*/
        randomPoints.push(
                new THREE.Vector3(-1000, 1000, 1000),
                new THREE.Vector3(-800, 1000, 900),
                new THREE.Vector3(-400, 1000, 800),
                new THREE.Vector3(200, 1000, 700),
                new THREE.Vector3(400, 1000, 400),
                new THREE.Vector3(600, 1000, -200),
                new THREE.Vector3(500, 1000, -600),
                new THREE.Vector3(900, 1000, - 1400),
                new THREE.Vector3(1300, 1000, -1400),
                new THREE.Vector3(1600, 1000, -1000),
        new THREE.Vector3(1600, 1000, -900),
        new THREE.Vector3(1500, 1000, -800),
        new THREE.Vector3(1300, 1000, -700),
        new THREE.Vector3(900, 1000, -700)
        );

        for(var i = 0; i < 14; i++) {
            randomPoints[i].y = groundMesh.getHeightAtPoint(randomPoints[i]);

           /* if(randomPoints[i].y < terrainMesh.getHeightAtPoint(randomPoints[i])) {
             randomPoints[i].y += 10;
             }*/
        }

        var splineCurve = new THREE.CatmullRomCurve3(randomPoints);

        var geometry = new THREE.Geometry();
        geometry.vertices = splineCurve.getPoints(2000);

        /*  for(var i = 0; i < 1000; i++) {
            geometry.vertices[i].y = terrainMesh.getHeightAtPoint(geometry.vertices[i]);
        }   */

        var irregularMaterial = new THREE.LineBasicMaterial( {color: 0x0000ff} );

        var splineCurveObject = new THREE.Line(geometry, irregularMaterial);
        scene.add(splineCurveObject);

        splineCurveObject.position.set(1000,100,1000);

        // End move to MovementAndCamera

        //
        // Some other updates
        // What updates, when does these updates end??
        //


        //Old camera position, approximately on the middle of the map.
/*        camera.position.y = terrainMesh.getHeightAtPoint(camera.position) + 500;*/

        //New camera position, on the "southern" side of the map
        camera.position.x = -10000;
        camera.position.z = 3000;
        camera.position.y = groundMesh.getHeightAtPoint(camera.position) + 500;

       /* sunLight.object3d.lookAt(camera);*/

        var boxGeom = new THREE.BoxGeometry(100, 100, 100);
        var customBox = new THREE.Mesh(boxGeom);

        groundMesh.add(customBox);
        customBox.position.setY(groundMesh.getHeightAtPoint(customBox.position));

        //
        // Generate random positions for some number of boxes
        // Used in instancing. Better examples:
        //  * http://threejs.org/examples/#webgl_buffergeometry_instancing_dynamic
        //  * http://threejs.org/examples/#webgl_buffergeometry_instancing_billboards
        //

        // Make a buffer that can use instanced attributes
        var instancedBoxGeom = new THREE.InstancedBufferGeometry();
        // Copy geometry from a standard box.
        instancedBoxGeom.fromGeometry(new THREE.BoxGeometry(100, 100, 100));

        var numBoxes = 10;
        var center = new THREE.Vector3(0,0,0);
        var radius = 50 * worldHalfWidth;

        texture = new THREE.Texture();
        var texture2 = new THREE.Texture();


        // Guessing the start of generating objects is here, make a function and move it
        var manager = new THREE.LoadingManager();
        manager.onProgress = function ( item, loaded, total ) {

            console.log( item, loaded, total );
        };

        var loader = new THREE.ImageLoader( manager );
        loader.load( 'resources/textures/samples/terrain/tree/palm_tree/diffuse.png', function ( image ) {
            texture.image = image;
/*            texture.transparent = true;
            texture.opacity = 0.01;*/
            texture.needsUpdate = true;
        } );




        objectLoader = new THREE.OBJLoader( manager );

        models = ['models/palmTrees/palm_straight.obj', 'models/palmTrees/palm_bend.obj',
            'models/palmTrees/palm_dual.obj', 'models/palmTrees/palm_trio.obj',
            'resources/mesh/samples/terrain/plants/tropical_plant2/tropical_plant.obj' ];

        j = 0;
/*        var palmShadow;

        var plantShadow;*/
        for(var i = 0; i < numBoxes; i++) {

            if(j === 4) {
                j = 0;
            }
            objectLoader.load( models[j], function ( object ) {

                object.traverse( function ( child ) {

                    if ( child instanceof THREE.Mesh ) {

                        child.material.map = texture;

                    }

                } );

                var bbox = new THREE.Box3().setFromObject(object);
                var randx = radius * (2*Math.random() - 1);
                var randy = radius * (2*Math.random() - 1);
                var randz = radius * (2*Math.random() - 1);

                object.position.set(randx, randy, randz);
                object.position.y = groundMesh.getHeightAtPoint(object.position);
                /*object.position.y -= bbox.min.y;*/
                object.castShadow = true;
                object.receiveShadows = true;
                object.transparent = true;
                object.opacity = 0.01;

                object.name = "Palm";

                /*palmShadow = new THREE.ShadowMesh(object);*/
                if(object.position.y > (waterLevel + 70)) {
                    groundMesh.add(object);
                 /*   terrainMesh.add(palmShadow);*/
                }


            }, onProgress, onError );
            j++;
        }


        loader.load( 'resources/textures/samples/terrain/plants/tropical_plant2/diffuse.png', function ( image ) {

            texture2.image = image;
            texture2.needsUpdate = true;

        } );

        for(var i = 0; i < numBoxes; i++) {

            objectLoader.load(models[4], function (object) {

                object.traverse(function (child) {

                    if (child instanceof THREE.Mesh) {

                        child.material.map = texture2;

                    }

                });

                var bbox = new THREE.Box3().setFromObject(object);
                var randx = radius * (2 * Math.random() - 1);
                var randy = radius * (2 * Math.random() - 1);
                var randz = radius * (2 * Math.random() - 1);

                object.position.set(randx, randy, randz);
                object.position.y = groundMesh.getHeightAtPoint(object.position);
                /*object.position.y -= bbox.min.y;*/

                object.name = "Tropical plant";

                object.castShadow = true;
                object.receiveShadows = true;

                if (object.position.y > (waterLevel + 70)) {
                    groundMesh.add(object);
                }


            }, onProgress, onError);
            j++;
        }



        spritemodels = ["resources/textures/samples/terrain/tree/palm_tree/palm_straight.png",
                            "resources/textures/samples/terrain/tree/palm_tree/palm_dual.png",
                            "resources/textures/samples/terrain/tree/palm_tree/palm_bend.png",
                            "resources/textures/samples/terrain/tree/palm_tree/palm_bend_dual.png",
                            "resources/textures/samples/terrain/tree/palm_tree/palm_trio.png"
                        ];

        spriteGeom = new THREE.Geometry();


        for(var i = 0; i < numBoxes; i++) {

            spriteTexture = THREE.ImageUtils.loadTexture( spritemodels[4] );
            spriteTexture.minFilter = THREE.NearestFilter;
            if(j === 4) {
                j = 0;
            }
            var randx = radius * (2 * Math.random() - 1);
            var randy = radius * (2 * Math.random() - 1);
            var randz = radius * (2 * Math.random() - 1);


            palmSprite = new THREE.PointsMaterial({
                size: 200,
                sizeAttenuation: true,
                map: spriteTexture,
                transparent: true,
                color: 0XFFFFFF
            });

            spriteGeom.vertices.push(new THREE.Vector3(randx, 1000, randz));
            myPalm = new THREE.Points(spriteGeom, palmSprite);
            myPalm.sortParticles = true;
            myPalm.y = groundMesh.getHeightAtPoint(myPalm.position);
            groundMesh.add(myPalm);

            j++;
        }
        //myPalm.position.set(100, terrainMesh.getHeightAtPoint(myPalm.position), 100);
/*        terrainMesh.add(palmSprite);
        palmSprite.position.set()*/

/*        var testMat = new THREE.MeshBasicMaterial({color:0xFF0000});
        var test = new THREE.SphereGeometry();
        var testMesh = new THREE.Mesh(test, testMat);
        terrainMesh.add(testMesh);
        testMesh.scale.set(100, 100, 100);
        testMesh.position.set(100, 10500, 100);
        testMesh.position.y = terrainMesh.getHeightAtPoint(testMesh.position) + 6000;
        testMesh.castShadow = true;*/

        var instancedMaterial = new THREE.ShaderMaterial( {
            uniforms: {
                color: { type: "c" , value: new THREE.Color(Math.random(), Math.random(), Math.random()) }
            },
            vertexShader: document.getElementById("instanced-vshader").textContent,
            fragmentShader: document.getElementById("fshader").textContent
        } );

        var instancedBox = new THREE.Mesh(instancedBoxGeom, instancedMaterial);
        instancedBox.name = "instancedBox";

        //terrainMesh.add(instancedBox);

        //
        // Set up renderer
        // Seen this done better, cleaner. We need to do this
        //

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true } );
        renderer.setClearColor( 0xbfd1e5 );
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( window.innerWidth, window.innerHeight );
        renderer.autoClear = false;

        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.shadowDarkness = 1.0;
        container.innerHTML = "";

        container.appendChild( renderer.domElement );

        stats = new Stats();
        stats.domElement.style.position = 'absolute';
        stats.domElement.style.top = '0px';
        container.appendChild( stats.domElement );

        window.addEventListener( 'resize', onWindowResize, false );

    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize( window.innerWidth, window.innerHeight );
        controls.handleResize();
    }

    // Seen both animate and render functions done in a different way thight might be better for us
    // Should change it
    function animate() {

        requestAnimationFrame( animate );

        angle +=0.009;
        sunLight.update(angle);

        lensFlare.position.set(sunLight.object3d.position.x, sunLight.object3d.position.y, sunLight.object3d.position.z);

        render();
        stats.update();

    }

    function render() {
        controls.update( clock.getDelta() );

        renderer.clear();
        renderer.render( scene, camera );
    }

    // Do we use onProgress and onError
    // Do we need it
    function onProgress( xhr ) {
        if ( xhr.lengthComputable ) {
            var percentComplete = xhr.loaded / xhr.total * 100;
            console.log( Math.round(percentComplete, 2) + '% downloaded' );
        }
    }



    function onError( xhr ) {}

</script>

<img src="textures/heightmapIsland4.jpeg" id="groundmap" hidden/>
<img src="textures/mountainmap.jpeg" id="mountainmap" hidden/>
<img src="textures/lavamap.jpeg" id="lavamap" hidden/>
<img src="textures/roadheightmap2.jpeg" id="roadheightmap" hidden/>
<img src="textures/watermap.jpg" id="watermap" hidden/>

<img src="textures/junglefloortexture.jpg" id="groundtexture" hidden/>
<img src="textures/dirtroadtexture.jpg" id="dirtroadtexture" hidden/>
<img src="textures/watertexture.jpg" id="watertexture" hidden/>



</body>
<