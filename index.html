
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Jungel</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            color: #61443e;
            font-family:Monospace;
            font-size:13px;
            text-align:center;

            background-color: #bfd1e5;
            margin: 0px;
            overflow: hidden;
        }

        #info {
            position: absolute;
            top: 0px; width: 100%;
            padding: 5px;
        }

        a {

            color: #a06851;
        }

    </style>
</head>
<body>

<div id="container"><br /><br /><br /><br /><br />Generating world...</div>
<div id="info"><a href="http://threejs.org" target="_blank">three.js</a> - webgl terrain demo<br />(left click: forward, right click: backward)</div>

<script src="bower_components/three.js/build/three.js"></script>

<script src="bower_components/three.js/examples/js/loaders/DDSLoader.js"></script>
<script src="bower_components/three.js/examples/js/loaders/MTLLoader.js"></script>
<script src="bower_components/three.js/examples/js/loaders/OBJMTLLoader.js"></script>

<script src="bower_components/three.js/examples/js/controls/FirstPersonControls.js"></script>

<script src="bower_components/three.js/examples/js/ImprovedNoise.js"></script>
<script src="bower_components/three.js/examples/js/Detector.js"></script>
<script src="bower_components/three.js/examples/js/libs/stats.min.js"></script>

<script src="src/HeightMapGeometry.js"></script>
<script src="src/HeightMapMesh.js"></script>

<script id="instanced-vshader" type="x-shader/x-vertex">
		// Other attributes and uniforms are supposed to be filled in by Three.js
		// To avoid it being filled in automatically, use RawShaderMaterial

        // Instanced attribute, updated only when a new instance is drawn (ie. when all vertices have been drawn and
        // we're going to draw a slightly different one.
		attribute vec3 translate;


		varying vec2 vUv;

		void main() {

			vec4 mvPosition = modelViewMatrix * vec4( translate + position, 1.0 );

			vUv = uv;

			gl_Position = projectionMatrix * mvPosition;

		}

	</script>

<script id="fshader" type="x-shader/x-fragment">
        // Other attributes and uniforms are supposed to be filled in by Three.js
		// To avoid it being filled in automatically, use RawShaderMaterial

           uniform vec3 color;

		void main() {

			gl_FragColor = vec4(color, 1.0);

		}
	</script>

<script>

    if ( ! Detector.webgl ) {

        Detector.addGetWebGLMessage();
        document.getElementById( 'container' ).innerHTML = "";

    }


    var container, stats;

    var camera, controls, scene, renderer;

    var terrainData, terrainMesh, terrainTexture, dirtroadMesh;

    /*Ground texture*/
    var groundtexture = THREE.ImageUtils.loadTexture( "textures/junglefloortexture.jpg" );
    groundtexture.wrapS = THREE.RepeatWrapping;
    groundtexture.wrapT = THREE.RepeatWrapping;
    groundtexture.repeat.set( 64, 64 );

    /*Dirt road texture*/
    var dirtroadtexture = THREE.ImageUtils.loadTexture("textures/dirtroadtexture.jpg");
    dirtroadtexture.wrapS = THREE.RepeatWrapping;
    dirtroadtexture.wrapT = THREE.RepeatWrapping;
    dirtroadtexture.repeat.set( 64, 64 );

    var worldWidth = 512, worldDepth = 512,
            worldHalfWidth = worldWidth / 2, worldHalfDepth = worldDepth / 2;

    var clock = new THREE.Clock();

    window.onload = function() {
        init();
        animate();
    };

    function init() {
        "use strict";

        container = document.getElementById('container');

        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 20000);
        camera.name = 'camera';

        scene = new THREE.Scene();

        controls = new THREE.FirstPersonControls(camera);
        controls.movementSpeed = 1000;
        controls.lookSpeed = 0.1;

        //
        // Lights
        //

        // Needed for materials using phong shading
        var ambientLight = new THREE.AmbientLight(0xffffff);
        ambientLight.name = 'ambientLight';
        scene.add(ambientLight);

        var directionalLight = new THREE.DirectionalLight(0xffffff);
        directionalLight.name = 'sun';
        directionalLight.position.set(1, 1, 0).normalize();
        //directionalLight.rotateZ(45 *Math.PI/180);
        scene.add(directionalLight);

        scene.add(new THREE.DirectionalLightHelper(directionalLight, 10));

        //
        // Height map generation/extraction
        //

        var useRandomHeightMap = false;

        if (useRandomHeightMap) {
            terrainData = generateHeight( worldWidth, worldDepth );
        } else {
            var heightMapImage = document.getElementById('heightmap');
            terrainData = getPixelValues(heightMapImage, 'r');
            worldWidth = heightMapImage.width;
            worldDepth = heightMapImage.height;
            worldHalfWidth = Math.floor(worldWidth / 2);
            worldHalfDepth = Math.floor(worldDepth / 2);
        }

        // Not required to use the generated texture
        terrainTexture = new THREE.CanvasTexture( generateTexture( terrainData, worldWidth, worldDepth ) );
        terrainTexture.wrapS = THREE.ClampToEdgeWrapping;
        terrainTexture.wrapT = THREE.ClampToEdgeWrapping;

        //
        // Generate terrain geometry and mesh
        //

        var heightMapGeometry = new HeightMapBufferGeometry(terrainData, worldWidth, worldDepth);
        // We scale the geometry to avoid scaling the node, since scales propagate.
        heightMapGeometry.scale(50*worldWidth, 1000, 50*worldDepth);

        var dirtroadGeometry = new HeightMapBufferGeometry(terrainData, worldWidth, worldDepth);
        dirtroadGeometry.scale(40*worldWidth, 1000, 40*worldDepth);

        terrainMesh = new HeightMapMesh( heightMapGeometry, new THREE.MeshBasicMaterial( { map: groundtexture } ) );
        terrainMesh.name = "terrain";
        scene.add( terrainMesh );

        dirtroadMesh = new HeightMapMesh( dirtroadGeometry, new THREE.MeshBasicMaterial( { map: dirtroadtexture } ) );
        dirtroadMesh.name = "dirtroad";
        scene.add(dirtroadMesh);


        var randomPoints = [];

        for(var i = 0; i < 100; i++) {
            randomPoints.push(new THREE.Vector3(Math.random() * 4000 - 2000, Math.random()
                    * 4000 - 2000, Math.random() * 4000 - 2000));
        }

/*        var curve = new THREE.Line(randomPoints, material);*/

        /*var path = new THREE.Path(curve.getPoints(50));*/

        var path = new THREE.CircleGeometry(2, 50);
        /*var geometry = path.createPointsGeometry(50);*/
        var material = new THREE.LineBasicMaterial( {color: 0xff0000} );

        var curve = new THREE.SplineCurve3(randomPoints);
        var splineObject = new THREE.Line(path, material);

        scene.add(splineObject);

        scene.add(curve);

        splineObject.rotateX(135);
        splineObject.scale.set(500, 500, 500);
        splineObject.position.set(1000,1700,1000);
        //
        // Some other updates
        //

        camera.position.y = terrainMesh.getHeightAtPoint(camera.position) + 500;

        var boxGeom = new THREE.BoxGeometry(100, 100, 100);
        var customBox = new THREE.Mesh(boxGeom);

        terrainMesh.add(customBox);
        customBox.position.setY(terrainMesh.getHeightAtPoint(customBox.position));

        //
        // Model loading
        // Examples: all loader/* examples on threejs.org/examples
        //

        // There are several other model loaders for other types, just look in Three.js' example folder.
        var objectMaterialLoader = new THREE.OBJMTLLoader();

        objectMaterialLoader.load(
                'models/lowPolyTree/lowpolytree.obj',
                'models/lowPolyTree/lowpolytree.mtl',
                function setUpLowPolyTree( object ) {
                    // Custom function to handle what's supposed to happen once we've loaded the model
                    object.scale.set(100, 100, 100);

                    var bbox = new THREE.Box3().setFromObject(object);

                    object.position.set(100, 0, 100);
                    object.position.y = terrainMesh.getHeightAtPoint(object.position);

                    // We should know where the bottom of our object is
                    object.position.y -= bbox.min.y;

                    object.name = "LowPolyTree";

                    terrainMesh.add( object );
                }, onProgress, onError );

        objectMaterialLoader.load(
                'models/rocks/rock1/Rock1.obj',
                'models/rocks/rock1/Rock1.mtl',
                function setUpRock( object ) {
                    // Custom function to handle what's supposed to happen once we've loaded the model

                    // Sometimes models contain uninteresting parts, extract meaningfull parts.
                    var interestingObject = object.children[1].children[1];
                    interestingObject.scale.set(100, 100, 100);

                    var bbox = new THREE.Box3().setFromObject(interestingObject);

                    interestingObject.position.set(200, 0, 200);
                    interestingObject.position.y = terrainMesh.getHeightAtPoint(object.position);

                    interestingObject.position.y -= bbox.min.y;

                    interestingObject.name = "rock1";
                    //interestingObject.material.map = THREE.ImageUtils.loadTexture('models/rocks/rock1/Rock-Texture-Surface.jpg');
                    interestingObject.material.map = null;
                    interestingObject.material.color = new THREE.Color(0.1, 0.1, 0.1);

                    terrainMesh.add( interestingObject );
                }, onProgress, onError );

        //
        // Generate random positions for some number of boxes
        // Used in instancing. Better examples:
        //  * http://threejs.org/examples/#webgl_buffergeometry_instancing_dynamic
        //  * http://threejs.org/examples/#webgl_buffergeometry_instancing_billboards
        //

        // Make a buffer that can use instanced attributes
        var instancedBoxGeom = new THREE.InstancedBufferGeometry();
        // Copy geometry from a standard box.
        instancedBoxGeom.fromGeometry(new THREE.BoxGeometry(100, 100, 100));

        var numBoxes = 1000;
        var center = new THREE.Vector3(0,0,0);
        var radius = 50 * worldHalfWidth;

        var translationArray = generateRandomPositions(numBoxes, center, radius);

        for (var i = 0, i3 = 0; i < numBoxes; ++i, i3 += 3) {
            // Correct height positions
            var pos = new THREE.Vector3().fromArray(translationArray, i3);
            pos.y = terrainMesh.getHeightAtPoint(pos);
            pos.toArray(translationArray, i3);
        }

        // Lots of other possibilities, eg: custom color per object, objects changing (requires dynamic
        // InstancedBufferAttribute, see its setDynamic), but require more shader magic.
        instancedBoxGeom.addAttribute( "translate", new THREE.InstancedBufferAttribute(translationArray, 3, 1) );

        var instancedMaterial = new THREE.ShaderMaterial( {
            uniforms: {
                color: { type: "c" , value: new THREE.Color(Math.random(), Math.random(), Math.random()) }
            },
            vertexShader: document.getElementById("instanced-vshader").textContent,
            fragmentShader: document.getElementById("fshader").textContent
        } );

        var instancedBox = new THREE.Mesh(instancedBoxGeom, instancedMaterial);
        instancedBox.name = "instancedBox";

        terrainMesh.add(instancedBox);

        //
        // Set up renderer
        //

        renderer = new THREE.WebGLRenderer();
        renderer.setClearColor( 0xbfd1e5 );
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( window.innerWidth, window.innerHeight );

        container.innerHTML = "";

        container.appendChild( renderer.domElement );

        stats = new Stats();
        stats.domElement.style.position = 'absolute';
        stats.domElement.style.top = '0px';
        container.appendChild( stats.domElement );

        //

        window.addEventListener( 'resize', onWindowResize, false );

    }

    function onWindowResize() {

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize( window.innerWidth, window.innerHeight );

        controls.handleResize();

    }

    function generateHeight( width, height ) {

        var size = width * height, data = new Uint8Array( size ),
                perlin = new ImprovedNoise(), quality = 1, z = Math.random() * 100;

        for ( var j = 0; j < 4; j ++ ) {

            for ( var i = 0; i < size; i ++ ) {

                var x = i % width, y = ~~ ( i / width );
                data[ i ] += Math.abs( perlin.noise( x / quality, y / quality, z ) * quality * 1.75 );

            }

            quality *= 5;

        }

        return data;

    }

    function generateTexture( data, width, height ) {

        var canvas, canvasScaled, context, image, imageData,
                level, diff, vector3, sun, shade;

        vector3 = new THREE.Vector3( 0, 0, 0 );

        sun = new THREE.Vector3( 1, 1, 1 );
        sun.normalize();

        canvas = document.createElement( 'canvas' );
        canvas.width = width;
        canvas.height = height;

        context = canvas.getContext( '2d' );
        context.fillStyle = '#000';
        context.fillRect( 0, 0, width, height );

        image = context.getImageData( 0, 0, canvas.width, canvas.height );
        imageData = image.data;

        for ( var i = 0, j = 0, l = imageData.length; i < l; i += 4, j ++ ) {

            vector3.x = data[ j - 2 ] - data[ j + 2 ];
            vector3.y = 2;
            vector3.z = data[ j - width * 2 ] - data[ j + width * 2 ];
            vector3.normalize();

            shade = vector3.dot( sun );

            imageData[ i ] = ( 96 + shade * 128 ) * ( 0.5 + data[ j ] * 0.007 );
            imageData[ i + 1 ] = ( 32 + shade * 96 ) * ( 0.5 + data[ j ] * 0.007 );
            imageData[ i + 2 ] = ( shade * 96 ) * ( 0.5 + data[ j ] * 0.007 );
        }

        context.putImageData( image, 0, 0 );

        // Scaled 4x

        canvasScaled = document.createElement( 'canvas' );
        canvasScaled.width = width * 4;
        canvasScaled.height = height * 4;

        context = canvasScaled.getContext( '2d' );
        context.scale( 4, 4 );
        context.drawImage( canvas, 0, 0 );

        image = context.getImageData( 0, 0, canvasScaled.width, canvasScaled.height );
        imageData = image.data;

        for ( var i = 0, l = imageData.length; i < l; i += 4 ) {

            var v = ~~ ( Math.random() * 5 );

            imageData[ i ] += v;
            imageData[ i + 1 ] += v;
            imageData[ i + 2 ] += v;

        }

        context.putImageData( image, 0, 0 );

        return canvasScaled;

    }

    //

    function animate() {

        requestAnimationFrame( animate );

        render();
        stats.update();

    }

    function render() {

        controls.update( clock.getDelta() );
        renderer.render( scene, camera );

    }

    /**
     * Extract pixel values from image elements. Not guaranteed to contain exactly the same values as
     * the image file.
     * @param {HTMLImageElement} domImage an image.
     * @param {string} [pixelComponents='rgba'] the color components to extract
     * @returns {array|Uint8ClampedArray} a color array
     */
    function getPixelValues(domImage, pixelComponents) {
        "use strict";
        var canvas = document.createElement('canvas');
        canvas.width = domImage.width;
        canvas.height = domImage.height;

        var context2d = canvas.getContext('2d');
        context2d.drawImage(domImage, 0, 0, domImage.width, domImage.height);

        var imageData = context2d.getImageData(0, 0, domImage.width, domImage.height);

        var componentExtractor = [];

        if (pixelComponents === undefined) {
            pixelComponents = 'rgba';
        }

        if (pixelComponents === 'r') { // Could extend this to other kinds of component extractors (eg. 'g', 'b','rb')
            componentExtractor = [0];
        } else if (pixelComponents === 'rg') {
            componentExtractor = [0,1];
        } else if (pixelComponents === 'rgb') {
            componentExtractor = [0,1,2];
        }else if (pixelComponents === 'rgba') {
            componentExtractor = [0,1,2,3];
            // return imageData.data;
        } else {
            console.error("unknown color component type");
            return [];
        }

        var imageSize = imageData.height * imageData.width;
        console.log(imageSize, imageData.data.length, imageData.data.length/4);
        var numComponents = componentExtractor.length;

        var pixelData = new Uint8ClampedArray(imageSize * numComponents);

        for (var i= 0, i4 = 0; i < imageSize; i++, i4 += 4) {
            for (var componentIdx = 0; componentIdx < numComponents; componentIdx++) {
                pixelData[i*numComponents + componentIdx] = imageData.data[i4 + componentExtractor[componentIdx]];
            }
        }
        
        return pixelData;
    }

    /**
     * @param {Number} count number of positions
     * @param {THREE.Vector3} center where the position be centered about
     * @param {Number} radius the max area
     */
    function generateRandomPositions(count, center, radius) {
        var translationArray = new Float32Array(3 * count);

        var pos = new THREE.Vector3();
        for (var i = 0, i3 = 0; i < count; i++, i3 +=3) {
            // One method to generate random positions
            // TODO: make gauss distributed method, f.ex
            pos.x = radius * (2*Math.random() - 1);
            pos.y = radius * (2*Math.random() - 1);
            pos.z = radius * (2*Math.random() - 1);

            pos.add(center);
            //translationArray[i3 + 0] = pos.x;
            //translationArray[i3 + 1] = pos.y;
            //translationArray[i3 + 2] = pos.z;

            pos.toArray(translationArray, i3);
        }

        return translationArray;
    }

    function onProgress( xhr ) {
        if ( xhr.lengthComputable ) {
            var percentComplete = xhr.loaded / xhr.total * 100;
            console.log( Math.round(percentComplete, 2) + '% downloaded' );
        }
    }

    function onError( xhr ) {}

</script>

<img src="textures/heightmap.jpeg" id="heightmap" hidden/>
<img src="textures/junglefloortexture.jpg" id="groundtexture" hidden/>
<img src="textures/dirtroadtexture.jpg" id="dirtroadtexture" hidden/>

</body>
</html>
