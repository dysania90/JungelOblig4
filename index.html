<!DOCTYPE html>
<html lang="en">
<head>
    <title>Jungel</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link rel="stylesheet" href="style.css">
</head>
<body>

<div id="container"><br /><br /><br /><br /><br />Generating world...</div>
<div id="info"><a href="http://threejs.org" target="_blank">three.js</a> - webgl terrain demo<br />(left click: forward, right click: backward)</div>

<script src="bower_components/three.js/build/three.min.js"></script>
<script src="bower_components/three.js/build/three.js"></script>
<script src="bower_components/three.js/examples/js/loaders/OBJLoader.js"></script>
<script src="bower_components/three.js/examples/js/loaders/DDSLoader.js"></script>
<script src="bower_components/three.js/examples/js/loaders/MTLLoader.js"></script>
<script src="bower_components/three.js/examples/js/loaders/OBJMTLLoader.js"></script>
<script src="bower_components/three.js/examples/js/controls/FirstPersonControls.js"></script>
<script src="bower_components/three.js/examples/js/controls/OrbitControls.js"></script>
<script src="bower_components/three.js/examples/js/ImprovedNoise.js"></script>
<script src="bower_components/three.js/examples/js/Detector.js"></script>
<script src="bower_components/three.js/examples/js/libs/stats.min.js"></script>
<script src="bower_components/three.js/examples/js/libs/dat.gui.min.js"></script>
<script src="bower_components/three.js/examples/js/objects/ShadowMesh.js"></script>

<script src="src/HeightMapGeometry.js"></script>
<script src="src/HeightMapMesh.js"></script>
<script src="src/DayNightCycle.js"></script>
<script src="src/GenerateMap.js"></script>
<script src="src/GenerateObjects.js"></script>
<script src="src/GenerateTexture.js"></script>
<script src="src/Mirror.js"></script> 
<script src="src/Water.js"></script>

<script id="instanced-vshader" type="x-shader/x-vertex">
		// Other attributes and uniforms are supposed to be filled in by Three.js
		// To avoid it being filled in automatically, use RawShaderMaterial

        // Instanced attribute, updated only when a new instance is drawn (ie. when all vertices have been drawn and
        // we're going to draw a slightly different one.
		attribute vec3 translate;

		varying vec2 vUV;

		void main() {

			<!--vec4 mvPosition = modelViewMatrix * vec4( translate + position, 1.0 );-->
            vec4 pos = vec4(position, 1.0);
			vUV = uv;

			gl_Position = projectionMatrix * modelViewMatrix * pos;

		}

</script>

<script id="fshader" type="x-shader/x-fragment">
        // Other attributes and uniforms are supposed to be filled in by Three.js
		// To avoid it being filled in automatically, use RawShaderMaterial

           uniform sampler2D texture;
           varying vec2 vUV;
           <!--uniform vec3 color;-->

		void main() {
            vec4 sample = texture2D(texture, vUV);
			gl_FragColor = vec4(sample.xyz, sample.w);

		}
</script>

<script>
    // What is this, do we need it?
    if ( ! Detector.webgl ) {
        Detector.addGetWebGLMessage();
        document.getElementById( 'container' ).innerHTML = "";
    }

    var container, stats;

    var camera, controls, scene, renderer;

    // Probably GenerateMap
    var groundData, groundMesh, groundTexture, groundMapImage, groundGeometry,
            mountainData, mountainMesh, mountainTexture, mountainMapImage, mountainGeometry,
            lavaData, lavaMesh, lavaTexture,lavaMapImage, lavaGeometry,
            beachData, beachMesh, beachTexture, beachMapImage, beachGeometry;

    var water; 
    var waterMesh;
    var sunLight;
    var frameTime;
    var angle = 0.0;

    var urlPrefix;
    var urls;
    var textureCube;
    var shader;
    var skyBoxMaterial;
    var mat;
    var skyBox;

    var randomPoints;
    var randx;
    var randy;
    var randz;
    var bbox;

    var manager;
    var loader;

    var lensFlare;
    var flareColor;
    var textureFlare0;

    var objectLoader;
    var models;
    var j;

    var spriteModels;
    var spriteGeom;
    var spriteTexture;
    var palmSprite;
    var myPalm;

    var waterLevel;

    var waterNormals;
    var count;
    var splineCurve;
    var splineGeometry;
    var irregularMaterial;
    var splineCurveObject;
    var boxGeom;
    var customBox;
    var customBox2;
    var numBoxes;
    var center;
    var radius;
    var instancedMaterial;
    var instancedBox;
    var instancedBoxGeom;
    // WAAAAAY too many var stuff here. Move it where it belongs (GenerateTexture for the most part)
    /*Ground texture*/

      /*Palm texture*/
    var palmTexture;
    var plantTexture;

    var worldWidth, worldHeight ,
            worldHalfWidth, worldHalfHeight;

    var clock = new THREE.Clock();

    window.onload = function() {
        init();
        animate();
    };

    var parameters = { 
        width: 2000, 
        height: 2000, 
        widthSegments: 250, 
        heightSegments: 250, 
        depth: 1500, 
        param: 4, 
        filterparam: 1 
    };

    function init() {
        "use strict";

        container = document.getElementById('container');

        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 300000);
        camera.name = 'camera';

        scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0XFFFFFF, 0.0000085);

        controls = new THREE.FirstPersonControls(camera);
        controls.movementSpeed = 1500;
        controls.lookSpeed = 0.1;

        manager = new THREE.LoadingManager();
        manager.onProgress = function ( item, loaded, total ) {

            console.log( item, loaded, total );
        };

        loader = new THREE.ImageLoader( manager );

        ///////////////////////////////////////////////////////
        //                      Renderer                    //
        /////////////////////////////////////////////////////
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true } );
        renderer.setClearColor( 0xbfd1e5 );
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( window.innerWidth, window.innerHeight );
        renderer.autoClear = false;

        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.shadowDarkness = 1.0;
        container.innerHTML = "";

        container.appendChild( renderer.domElement );

        stats = new Stats();
        stats.domElement.style.position = 'absolute';
        stats.domElement.style.top = '0px';
        container.appendChild( stats.domElement );

        ///////////////////////////////////////////////////////
        //                      Lights                      //
        /////////////////////////////////////////////////////

        // Needed for materials using phong shading
        // This needs to be done differently
        var ambientLight = new THREE.AmbientLight(0xffffff);
        ambientLight.name = 'ambientLight';
        scene.add(ambientLight);

        sunLight = new DayNightCycle.sunLight();

        sunLight.name = 'sun';
        sunLight.object3d.position.set(10000, 10000, 10000);

        sunLight.object3d.castShadow = true;
        //sunLight.object3d.shadowCameraVisible = true;

        sunLight.object3d.castShadow = true;

        sunLight.object3d.shadowMapWidth = 512;
        sunLight.object3d.shadowMapHeight = 512;

        //directionalLight.shadowCameraNear = 5;
        sunLight.object3d.shadowCameraFar = 10000;
        //directionalLight.shadowCameraFov = 360;

        var d = 15000;
        sunLight.object3d.shadowCameraRight = d;
        sunLight.object3d.shadowCameraLeft = -d;
        sunLight.object3d.shadowCameraTop = d;
        sunLight.object3d.shadowCameraBottom = -d;

        sunLight.object3d.shadowDarkness = 0.5;

        sunLight.shadowCameraVisible = true;


        scene.add( sunLight.object3d );
        scene.add(new THREE.DirectionalLightHelper(sunLight.object3d, 100));

        textureFlare0 = THREE.ImageUtils.loadTexture("textures/solarFlare.png");
        textureFlare0.transparent = true;
        textureFlare0.opacity = 1.0;
        textureFlare0.minFilter = THREE.NearestFilter;

        flareColor = new THREE.Color(0xffaacc);
        lensFlare = new THREE.LensFlare(textureFlare0, 350, 0.0, THREE.AdditiveBlending, flareColor);

        lensFlare.add(textureFlare0, 60, 0.6, THREE.AdditiveBlending);
        lensFlare.add(textureFlare0, 70, 0.7, THREE.AdditiveBlending);
        lensFlare.add(textureFlare0, 120, 0.9, THREE.AdditiveBlending);
        lensFlare.add(textureFlare0, 70, 1.0, THREE.AdditiveBlending);

        lensFlare.position.set(sunLight.object3d.position.x, sunLight.object3d.position.y, sunLight.object3d.position.z);
        //lensFlare.position.set(10000, 20000, 20000);
        //lensFlare.position = sunLight.object3d.position;

        scene.add(lensFlare);

        // Height map generation/extraction
        // Needs to move to GenerateMap
        //


        ///////////////////////////////////////////////////////
        //                      Meshes                      //
        /////////////////////////////////////////////////////

        //
        // This need to move to GenerateMap
        //

        //Ground
        groundMapImage = document.getElementById('groundmap');
        groundData = GenerateMap.getPixelValues(groundMapImage, 'r');

        worldWidth = groundMapImage.width;
        worldHeight = groundMapImage.height;
        worldHalfWidth = Math.floor(worldWidth / 2);
        worldHalfHeight = Math.floor(worldHeight / 2);

        groundGeometry = new HeightMapBufferGeometry(groundData, worldWidth, worldHeight);
        groundGeometry.scale(50*worldWidth, 4500, 50*worldHeight);

        groundTexture = THREE.ImageUtils.loadTexture( "textures/groundDirtTexture.jpg" );
        groundTexture.wrapS = groundTexture.wrapT = THREE.RepeatWrapping;
        groundTexture.repeat.set( 256, 256 );

        groundMesh = new HeightMapMesh( groundGeometry,  new THREE.MeshLambertMaterial( { map: groundTexture } ));
        groundMesh.name = "terrain";
        groundMesh.receiveShadows = true;
        scene.add( groundMesh );

        //Mountain
        mountainMapImage = document.getElementById('mountainmap');
        mountainData = GenerateMap.getPixelValues(mountainMapImage, 'r');

        mountainGeometry = new HeightMapBufferGeometry(mountainData, worldWidth, worldHeight);
        mountainGeometry.scale(50*worldWidth, 4500, 50*worldHeight);

        mountainTexture = THREE.ImageUtils.loadTexture( "textures/mountainTexture.jpg" );
        mountainTexture.wrapS = mountainTexture.wrapT = THREE.RepeatWrapping;
        mountainTexture.repeat.set( 64, 64 );

        mountainMesh = new HeightMapMesh( mountainGeometry, new THREE.MeshLambertMaterial( { map: mountainTexture } ) );
        mountainMesh.name = "mountain";
        groundMesh.add(mountainMesh);

        //Lava
        lavaMapImage = document.getElementById('lavamap');
        lavaData = GenerateMap.getPixelValues(lavaMapImage, 'r');

        lavaGeometry = new HeightMapBufferGeometry(lavaData, worldWidth, worldHeight);
        lavaGeometry.scale(50*worldWidth, 4500, 50*worldHeight);

        lavaTexture = THREE.ImageUtils.loadTexture( "textures/lavaTexture.jpg" );
        lavaTexture.wrapS = lavaTexture.wrapT = THREE.RepeatWrapping;
        lavaTexture.repeat.set( 64, 64 );

        lavaMesh = new HeightMapMesh( lavaGeometry, new THREE.MeshBasicMaterial( { map: lavaTexture } ) );
        lavaMesh.name = "lava";
        groundMesh.add(lavaMesh);

        //Beach
        beachMapImage = document.getElementById('beachmap');
        beachData = GenerateMap.getPixelValues(beachMapImage, 'r');

        beachGeometry = new HeightMapBufferGeometry(beachData, worldWidth, worldHeight);
        beachGeometry.scale(50*worldWidth, 4500, 50*worldHeight);

        beachTexture = THREE.ImageUtils.loadTexture( "textures/beachTexture.jpg" );
        beachTexture.wrapS = beachTexture.wrapT = THREE.RepeatWrapping;
        beachTexture.repeat.set( 64, 64 );

        beachMesh = new HeightMapMesh( beachGeometry, new THREE.MeshLambertMaterial( { map: beachTexture } ) );
        beachMesh.name = "beach";
        groundMesh.add(beachMesh);

        //Water

        waterNormals = new THREE.ImageUtils.loadTexture( 'textures/waternormals.jpg' );
        waterNormals.wrapS = waterNormals.wrapT = THREE.RepeatWrapping;
        water = new THREE.Water( renderer, camera, scene, {
            textureWidth: 512,
            textureHeight: 512,
            waterNormals: waterNormals,
            alpha: 	1.0,
            sunDirection:  ambientLight.position.clone().normalize(),
            sunColor: 0xffffff,
            waterColor: 0x001e0f,
            distortionScale: 50.0,
        } );
        waterMesh = new THREE.Mesh(
                new THREE.PlaneBufferGeometry(parameters.width * 500, parameters.height * 500 ),
                water.material
        );

        water.opacity = 0.5;
        waterMesh.add( water );
        waterMesh.rotation.x = - Math.PI * 0.5;
        waterMesh.position.y += 70;
        scene.add( waterMesh );

        waterLevel = waterMesh.position.y;

        // AUDIO
        var listener = new THREE.AudioListener();
        scene.add(listener);
        var audio = new THREE.Audio(listener);
        audio.load('audio/rainforest.mp3');
        audio.autoplay = true;
        audio.setLoop(500);
        scene.add(audio);

        /////////////SKYBOX
        urlPrefix = 'textures/';
        urls = [ urlPrefix + 'sea_negx.jpg',
            urlPrefix + 'sea_neutral.jpg',
            urlPrefix + 'sea_negy.jpg',
            urlPrefix + 'sea_posy.jpg',
            urlPrefix + 'sea_negz.jpg',
            urlPrefix + 'sea_posz.jpg' ];


        textureCube = THREE.ImageUtils.loadTextureCube(urls);
        textureCube.format = THREE.RGBFormat;


        shader = THREE.ShaderLib['cube']; // init cube shader from built-in lib
        shader.uniforms['tCube'].value = textureCube; // apply textures to shader


        // create shader material
        skyBoxMaterial = new THREE.ShaderMaterial({
            fragmentShader : shader.fragmentShader,
            vertexShader : shader.vertexShader,
            uniforms : shader.uniforms,
            depthWrite : false,
            side : THREE.BackSide
        });


        mat = new THREE.MeshBasicMaterial({envMap : textureCube, side: THREE.BackSide});

        // create skybox mesh
        skyBox = new THREE.Mesh(new THREE.BoxGeometry(300000, 400000, 300000), mat);
        skyBox.doubleSided = true;


        groundMesh.add(skyBox);

        /*Irregulaert formet spline-kurve*/
        // Move this to MovementAndCamera and make it work!
        randomPoints = [];

        /*
        var num = 10;

        for(var i = 0; i < num; i++) {
            randomPoints.push(new THREE.Vector3(Math.random() * 4000 - 1500, Math.random()
                    * 3000 - 1500, Math.random() * 3000 - 1500));
        }

        for(var i = 0; i < num; i++) {
            randomPoints[i].y = terrainMesh.getHeightAtPoint(randomPoints[i]) + 1;
        }

        var negate = -2;
         */


                count = 1000;

        randomPoints.push(
                new THREE.Vector3(-1000, 1000, 1000),
                new THREE.Vector3(-800, 1000, 900),
                new THREE.Vector3(-400, 1000, 800),
                new THREE.Vector3(200, 1000, 700),
                new THREE.Vector3(400, 1000, 400),
                new THREE.Vector3(600, 1000, -200),
                new THREE.Vector3(500, 1000, -600),
                new THREE.Vector3(900, 1000, - 1400),
                new THREE.Vector3(1300, 1000, -1400),
                new THREE.Vector3(1600, 1000, -1000),
        new THREE.Vector3(1600, 1000, -900),
        new THREE.Vector3(1500, 1000, -800),
        new THREE.Vector3(1300, 1000, -700),
        new THREE.Vector3(900, 1000, -700)
        );

        for(var i = 0; i < 14; i++) {
            randomPoints[i].y = groundMesh.getHeightAtPoint(randomPoints[i]);

           /* if(randomPoints[i].y < terrainMesh.getHeightAtPoint(randomPoints[i])) {
             randomPoints[i].y += 10;
             }*/
        }


        splineCurve = new THREE.CatmullRomCurve3(randomPoints);

        splineGeometry = new THREE.Geometry();
        splineGeometry.vertices = splineCurve.getPoints(2000);

        /*  for(var i = 0; i < 1000; i++) {
            geometry.vertices[i].y = terrainMesh.getHeightAtPoint(geometry.vertices[i]);
        }   */


        irregularMaterial = new THREE.LineBasicMaterial( {color: 0x0000ff} );

        splineCurveObject = new THREE.Line(splineGeometry, irregularMaterial);
        scene.add(splineCurveObject);

        splineCurveObject.position.set(1000,100,1000);

        //Old camera position, approximately in the middle of the map.
/*        camera.position.y = terrainMesh.getHeightAtPoint(camera.position) + 500;*/

        //New camera position, on the "southern" side of the map
        camera.position.x = -6000;
        camera.position.z = 6900;
        camera.position.y = groundMesh.getHeightAtPoint(camera.position) + 350;

        boxGeom = new THREE.BoxGeometry(100, 100, 100);
        customBox = new THREE.Mesh(boxGeom);

        groundMesh.add(customBox);
        customBox.position.setY(groundMesh.getHeightAtPoint(customBox.position));

        customBox2 = new THREE.Mesh(boxGeom);
        customBox2.position.set(-4900,0, 3900);
        groundMesh.add(customBox2);
        customBox2.position.setY(groundMesh.getHeightAtPoint(customBox2.position)+ 200) ;

        //
        // Generate random positions for some number of boxes
        // Used in instancing. Better examples:
        //  * http://threejs.org/examples/#webgl_buffergeometry_instancing_dynamic
        //  * http://threejs.org/examples/#webgl_buffergeometry_instancing_billboards
        //

        // Make a buffer that can use instanced attributes
        instancedBoxGeom = new THREE.InstancedBufferGeometry();
        // Copy geometry from a standard box.
        instancedBoxGeom.fromGeometry(new THREE.BoxGeometry(100, 100, 100));

        numBoxes = 10;
        center = new THREE.Vector3(0,0,0);
        radius = 50 * worldHalfWidth;

        palmTexture = new THREE.Texture();
        plantTexture = new THREE.Texture();

        //generate3DPalmsAndPlants();

        generate2DPalmsAndPlants();


        instancedMaterial = new THREE.ShaderMaterial( {
            uniforms: {
                color: { type: "c" , value: new THREE.Color(Math.random(), Math.random(), Math.random()) }
            },
            vertexShader: document.getElementById("instanced-vshader").textContent,
            fragmentShader: document.getElementById("fshader").textContent
        } );

        instancedBox = new THREE.Mesh(instancedBoxGeom, instancedMaterial);
        instancedBox.name = "instancedBox";


        window.addEventListener( 'resize', onWindowResize, false );
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize( window.innerWidth, window.innerHeight );
        controls.handleResize();
    }

    // Seen both animate and render functions done in a different way thight might be better for us
    // Should change it
    function animate() {

        requestAnimationFrame( animate );          angle +=0.00001; 
        //sunLight.update(angle); 
        water.material.uniforms.time.value += angle; 
        lensFlare.position.set(sunLight.object3d.position.x, sunLight.object3d.position.y, sunLight.object3d.position.z);  

        render(); 
        stats.update();

    }

    function render() {
        //        renderer.clear(); //nullstiller alle fargebuffere etc 
        controls.update(clock.getDelta());
          //        controls.update(); 
        water.render(); 
        renderer.render( scene, camera ); 
    }

    // Do we use onProgress and onError
    // Do we need it
    function onProgress( xhr ) {
        if ( xhr.lengthComputable ) {
            var percentComplete = xhr.loaded / xhr.total * 100;
            console.log( Math.round(percentComplete, 2) + '% downloaded' );
        }
    }



    function onError( xhr ) {}

    function generate3DPalmsAndPlants() {
        // Guessing the start of generating objects is here, make a function and move it

        loader.load( 'resources/textures/samples/terrain/tree/palm_tree/diffuse.png', function ( image ) {
            palmTexture.image = image;
            /*            texture.transparent = true;
             texture.opacity = 0.01;*/
            palmTexture.needsUpdate = true;
        } );


        objectLoader = new THREE.OBJLoader( manager );

        models = ['models/palmTrees/palm_straight.obj', 'models/palmTrees/palm_bend.obj',
            'models/palmTrees/palm_dual.obj', 'models/palmTrees/palm_trio.obj',
            'resources/mesh/samples/terrain/plants/tropical_plant2/tropical_plant.obj' ];

        j = 0;

        for(var i = 0; i < numBoxes; i++) {

            if(j === 4) {
                j = 0;
            }
            objectLoader.load( models[j], function ( object ) {

                object.traverse( function ( child ) {

                    if ( child instanceof THREE.Mesh ) {

                        child.material.map = palmTexture;

                    }

                } );


                bbox = new THREE.Box3().setFromObject(object);
                randx = radius * (2*Math.random() - 1);
                randy = radius * (2*Math.random() - 1);
                randz = radius * (2*Math.random() - 1);

                object.position.set(randx, randy, randz);
                object.position.y = groundMesh.getHeightAtPoint(object.position);
                /*object.position.y -= bbox.min.y;*/
                object.castShadow = true;
                object.receiveShadows = true;
                object.transparent = true;
                object.opacity = 0.01;

                object.name = "Palm";

                /*palmShadow = new THREE.ShadowMesh(object);*/
                if(object.position.y > (waterLevel + 70)) {
                    groundMesh.add(object);
                    /*   terrainMesh.add(palmShadow);*/
                }


            }, onProgress, onError );
            j++;
        }


        loader.load( 'resources/textures/samples/terrain/plants/tropical_plant2/diffuse.png', function ( image ) {

            plantTexture.image = image;
            plantTexture.needsUpdate = true;

        } );

        for(var i = 0; i < numBoxes; i++) {

            objectLoader.load(models[4], function (object) {

                object.traverse(function (child) {

                    if (child instanceof THREE.Mesh) {

                        child.material.map = plantTexture;

                    }

                });

                bbox = new THREE.Box3().setFromObject(object);
                randx = radius * (2 * Math.random() - 1);
                randy = radius * (2 * Math.random() - 1);
                randz = radius * (2 * Math.random() - 1);

                object.position.set(randx, randy, randz);
                object.position.y = groundMesh.getHeightAtPoint(object.position);
                /*object.position.y -= bbox.min.y;*/

                object.name = "Tropical plant";

                object.castShadow = true;
                object.receiveShadows = true;

                if (object.position.y > (waterLevel + 70)) {
                    groundMesh.add(object);
                }


            }, onProgress, onError);
            j++;
        }
    }

    function generate2DPalmsAndPlants() {
        spriteModels = ["resources/textures/samples/terrain/tree/palm_tree/palm_straight2.png",
            "resources/textures/samples/terrain/tree/palm_tree/palm_dual.png",
            "resources/textures/samples/terrain/tree/palm_tree/palm_bend.png",
            "resources/textures/samples/terrain/tree/palm_tree/palm_bend_dual.png",
            "resources/textures/samples/terrain/tree/palm_tree/palm_trio.png"
        ];

        spriteGeom = new THREE.Geometry();


        for(var i = 0; i < numBoxes; i++) {

            spriteTexture = THREE.ImageUtils.loadTexture( spriteModels[0] );
            spriteTexture.minFilter = THREE.NearestFilter;
            if(j === 4) {
                j = 0;
            }

            radius = 800;
            randx = radius * (2 * Math.random() - 1);
            randy = radius * (2 * Math.random() - 1);
            randz = radius * (2 * Math.random() - 1);


            palmSprite = new THREE.PointsMaterial({
                size: 1000,
                sizeAttenuation: true,
                map: spriteTexture,
                transparent: true,
                color: 0XFFFFFF
            });

            var kk = new THREE.Vector3(randx,groundMesh.getHeightAtPoint(customBox2), randz);
            spriteGeom.vertices.push(kk);
            myPalm = new THREE.Points(spriteGeom, palmSprite);
            myPalm.sortParticles = true;

            customBox2.add(myPalm);

            j++;
        }
        //myPalm.position.set(100, terrainMesh.getHeightAtPoint(myPalm.position), 100);
        /*        groundMesh.add(palmSprite);
         palmSprite.position.set()*/
    }

</script>

<img src="textures/groundMap.jpeg" id="groundmap" hidden/>
<img src="textures/mountainMap.jpeg" id="mountainmap" hidden/>
<img src="textures/lavaMap.jpeg" id="lavamap" hidden/>
<img src="textures/beachMap.jpeg" id="beachmap" hidden/>

</body>
</html>