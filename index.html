<!DOCTYPE html>
<html lang="en">
<head>
    <title>Jungel</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link rel="stylesheet" href="style.css">
</head>
<body>

<div id="container"><br /><br /><br /><br /><br />Generating world...</div>
<div id="info"><a href="http://threejs.org" target="_blank">three.js</a> - webgl terrain demo<br />(left click: forward, right click: backward)</div>

<script src="bower_components/three.js/build/three.min.js"></script>
<script src="bower_components/three.js/build/three.js"></script>
<script src="bower_components/three.js/examples/js/loaders/OBJLoader.js"></script>
<script src="bower_components/three.js/examples/js/loaders/DDSLoader.js"></script>
<script src="bower_components/three.js/examples/js/loaders/MTLLoader.js"></script>
<script src="bower_components/three.js/examples/js/loaders/OBJMTLLoader.js"></script>
<script src="bower_components/three.js/examples/js/controls/FirstPersonControls.js"></script>
<script src="bower_components/three.js/examples/js/controls/OrbitControls.js"></script>
<script src="bower_components/three.js/examples/js/ImprovedNoise.js"></script>
<script src="bower_components/three.js/examples/js/Detector.js"></script>
<script src="bower_components/three.js/examples/js/libs/stats.min.js"></script>
<script src="bower_components/three.js/examples/js/libs/dat.gui.min.js"></script>
<script src="bower_components/three.js/examples/js/objects/ShadowMesh.js"></script>
<script src="bower_components/three.js/examples/js/postprocessing/BloomPass.js"></script>

<script src="src/HeightMapGeometry.js"></script>
<script src="src/HeightMapMesh.js"></script>
<script src="src/DayNightCycle.js"></script>
<script src="src/GenerateMap.js"></script>
<script src="src/GenerateObjects.js"></script>
<script src="src/GenerateTexture.js"></script>
<script src="src/Mirror.js"></script> 
<script src="src/Water.js"></script>

<script id="instanced-vshader" type="x-shader/x-vertex">
		// Other attributes and uniforms are supposed to be filled in by Three.js
		// To avoid it being filled in automatically, use RawShaderMaterial
        // Instanced attribute, updated only when a new instance is drawn (ie. when all vertices have been drawn and
        // we're going to draw a slightly different one.
		attribute vec3 translate;
		varying vec2 vUV;
		void main() {
			<!--vec4 mvPosition = modelViewMatrix * vec4( translate + position, 1.0 );-->
            vec4 pos = vec4(position, 1.0);
			vUV = uv;
			gl_Position = projectionMatrix * modelViewMatrix * pos;
		}
</script>

<script id="fshader" type="x-shader/x-fragment">
        // Other attributes and uniforms are supposed to be filled in by Three.js
		// To avoid it being filled in automatically, use RawShaderMaterial
           uniform sampler2D texture;
           varying vec2 vUV;
           <!--uniform vec3 color;-->
		void main() {
            vec4 sample = texture2D(texture, vUV);
			gl_FragColor = vec4(sample.xyz, sample.w);
		}
</script>

<script>
    // What is this, do we need it?
    if ( ! Detector.webgl ) {
        Detector.addGetWebGLMessage();
        document.getElementById( 'container' ).innerHTML = "";
    }
    var container, stats, gui;
    var camera, controls, scene, renderer, composer;
    var x, y, z;
    var x2, y2, z2;
    var flag = false;
    // Probably GenerateMap
    var groundData, groundMesh, groundTexture, groundMapImage, groundGeometry,
            mountainData, mountainMesh, mountainTexture, mountainMapImage, mountainGeometry,
            lavaMesh, lavaTexture,lavaGeometry,
            beachData, beachMesh, beachTexture, beachMapImage, beachGeometry;
    var water;
    var waterMesh;
    var sunLight;
    var frameTime;
    var angle = 0.0;
    var urlPrefix;
    var urls;
    var textureCube;
    var shader;
    var skyBoxMaterial;
    var mat;
    var skyBox;
    var splinePoints;
    var randx;
    var randy;
    var randz;
    var bbox;
    var manager;
    var loader;
    var objectMaterialLoader;
    var lensFlare;
    var flareColor;
    var textureFlare0;
    var objectLoader;

    var spriteModels;
    var spriteGeom;
    var spriteTexture;
    var palmSprite;
    var myPalm;
    var growthLowerLevel;
    var growthUpperLevel;
    var waterNormals;
    var count;
    var splineCurve;
    var splineGeometry;
    var splineMaterial;
    var splineCurveObject;
    var boxGeom;
    var growthPosition1;
    var growthPosition2;
    var numBoxes;
    var center;
    var radius;
    var instancedMaterial;
    var instancedBox;
    var instancedBoxGeom;
    // WAAAAAY too many var stuff here. Move it where it belongs (GenerateTexture for the most part)
    /*Ground texture*/
    /*Palm texture*/

    var worldWidth, worldHeight ,
            worldHalfWidth, worldHalfHeight;
    var clock = new THREE.Clock();
    window.onload = function() {
        init();
        animate();
    };
    var parameters = {
        width: 2000,
        height: 2000,
        widthSegments: 250,
        heightSegments: 250,
        depth: 1500,
        param: 4,
        filterparam: 1
    };
    function init() {
        "use strict";
        container = document.getElementById('container');
        /*        gui = new DAT.GUI({
         height : 5 * 32 - 1
         });
         var params = {
         x:0,
         y:0
         };
         gui.add(params, 'interation');*/
        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 300000);
        camera.name = 'camera';
        scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0XFFFFFF, 0.0000085);
        controls = new THREE.FirstPersonControls(camera);
        controls.movementSpeed = 1500;
        controls.lookSpeed = 0.1;
        manager = new THREE.LoadingManager();
        manager.onProgress = function ( item, loaded, total ) {
            console.log( item, loaded, total );
        };
        loader = new THREE.ImageLoader( manager );
        ///////////////////////////////////////////////////////
        //                      Renderer                    //
        /////////////////////////////////////////////////////
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true } );
        renderer.setClearColor( 0xbfd1e5 );
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( window.innerWidth, window.innerHeight );
        renderer.autoClear = false;
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.shadowDarkness = 1.0;
        container.innerHTML = "";
        container.appendChild( renderer.domElement );
        stats = new Stats();
        stats.domElement.style.position = 'absolute';
        stats.domElement.style.top = '0px';
        container.appendChild( stats.domElement );
        ///////////////////////////////////////////////////////
        //                      Lights                      //
        /////////////////////////////////////////////////////
        // Needed for materials using phong shading
        // This needs to be done differently
        var ambientLight = new THREE.AmbientLight(0xffffff);
        ambientLight.name = 'ambientLight';
        scene.add(ambientLight);
        sunLight = new DayNightCycle.sunLight();
        sunLight.name = 'sun';
        sunLight.object3d.position.set(10000, 10000, 10000);
        sunLight.object3d.castShadow = true;
        //sunLight.object3d.shadowCameraVisible = true;
        sunLight.object3d.castShadow = true;
        sunLight.object3d.shadowMapWidth = 512;
        sunLight.object3d.shadowMapHeight = 512;
        //directionalLight.shadowCameraNear = 5;
        sunLight.object3d.shadowCameraFar = 10000;
        //directionalLight.shadowCameraFov = 360;
        var d = 15000;
        sunLight.object3d.shadowCameraRight = d;
        sunLight.object3d.shadowCameraLeft = -d;
        sunLight.object3d.shadowCameraTop = d;
        sunLight.object3d.shadowCameraBottom = -d;
        sunLight.object3d.shadowDarkness = 0.5;
        sunLight.shadowCameraVisible = true;
        scene.add( sunLight.object3d );
        scene.add(new THREE.DirectionalLightHelper(sunLight.object3d, 100));
        textureFlare0 = THREE.ImageUtils.loadTexture("textures/solarFlare.png");
        textureFlare0.transparent = true;
        textureFlare0.opacity = 1.0;
        textureFlare0.alphaTest = 0.5;
        textureFlare0.minFilter = THREE.LinearMipMapLinearFilter;
        flareColor = new THREE.Color(0xffaacc);
        lensFlare = new THREE.LensFlare(textureFlare0, 350, 0.0, THREE.AdditiveBlending, flareColor);
        lensFlare.add(textureFlare0, 60, 0.6, THREE.AdditiveBlending);
        lensFlare.add(textureFlare0, 70, 0.7, THREE.AdditiveBlending);
        lensFlare.add(textureFlare0, 120, 0.9, THREE.AdditiveBlending);
        lensFlare.add(textureFlare0, 70, 1.0, THREE.AdditiveBlending);
        lensFlare.position.set(sunLight.object3d.position.x, sunLight.object3d.position.y, sunLight.object3d.position.z);
        //lensFlare.position.set(10000, 20000, 20000);
        //lensFlare.position = sunLight.object3d.position;
        scene.add(lensFlare);
        // Height map generation/extraction
        // Needs to move to GenerateMap
        //
        ///////BLOOOM
        /*        var renderModel = new THREE.RenderPass( scene, camera );
         var effectBloom = new THREE.BloomPass( 1.25 );
         var effectFilm = new THREE.FilmPass( 0.35, 0.95, 2048, false );
         effectFilm.renderToScreen = true;
         composer = new THREE.EffectComposer( renderer );
         composer.addPass( renderModel );
         composer.addPass( effectBloom );
         composer.addPass( effectFilm );*/
        ////
        ///////////////////////////////////////////////////////
        //                      Meshes                      //
        /////////////////////////////////////////////////////
        //
        // This need to move to GenerateMap
        //
        //Ground
        groundMapImage = document.getElementById('groundmap');
        groundData = GenerateMap.getPixelValues(groundMapImage, 'r');
        worldWidth = groundMapImage.width;
        worldHeight = groundMapImage.height;
        worldHalfWidth = Math.floor(worldWidth / 2);
        worldHalfHeight = Math.floor(worldHeight / 2);
        groundGeometry = new HeightMapBufferGeometry(groundData, worldWidth, worldHeight);
        groundGeometry.scale(50*worldWidth, 4500, 50*worldHeight);
        groundTexture = THREE.ImageUtils.loadTexture( "textures/groundDirtTexture.jpg" );
        groundTexture.wrapS = groundTexture.wrapT = THREE.RepeatWrapping;
        groundTexture.repeat.set( 256, 256 );
        groundTexture.magFilter = THREE.NearestFilter;
        groundTexture.minFilter = THREE.LinearMipMapLinearFilter;
        groundMesh = new HeightMapMesh( groundGeometry,  new THREE.MeshLambertMaterial( { map: groundTexture } ));
        groundMesh.name = "terrain";
        groundMesh.receiveShadows = true;
        scene.add( groundMesh );

        //Mountain
        mountainMapImage = document.getElementById('mountainmap');
        mountainData = GenerateMap.getPixelValues(mountainMapImage, 'r');
        mountainGeometry = new HeightMapBufferGeometry(mountainData, worldWidth, worldHeight);
        mountainGeometry.scale(50*worldWidth, 4500, 50*worldHeight);
        mountainTexture = THREE.ImageUtils.loadTexture( "textures/mountainTexture.jpg" );
        mountainTexture.wrapS = mountainTexture.wrapT = THREE.RepeatWrapping;
        mountainTexture.repeat.set( 64, 64 );
        mountainTexture.magFilter = THREE.NearestFilter;
        mountainTexture.minFilter = THREE.LinearMipMapLinearFilter;
        mountainMesh = new HeightMapMesh( mountainGeometry, new THREE.MeshLambertMaterial( { map: mountainTexture } ) );
        mountainMesh.name = "mountain";
        groundMesh.add(mountainMesh);

        //Lava
        lavaTexture = THREE.ImageUtils.loadTexture( "textures/lavaTexture.jpg" );
        lavaTexture.wrapS = lavaTexture.wrapT = THREE.RepeatWrapping;
        /*        lavaTexture.repeat.set( 64, 64 );*/
        lavaGeometry = new THREE.CircleGeometry(700, 1000);
        lavaMesh = new THREE.Mesh(lavaGeometry,new THREE.MeshLambertMaterial({side: THREE.DoubleSide, map: lavaTexture}));
        lavaMesh.position.set(2457, 3118, -7502);
        lavaMesh.rotation.x = Math.PI /2;
        scene.add(lavaMesh);

        //Beach
        beachMapImage = document.getElementById('beachmap');
        beachData = GenerateMap.getPixelValues(beachMapImage, 'r');
        beachGeometry = new HeightMapBufferGeometry(beachData, worldWidth, worldHeight);
        beachGeometry.scale(50*worldWidth, 4500, 50*worldHeight);
        beachTexture = THREE.ImageUtils.loadTexture( "textures/beachTexture.jpg" );
        beachTexture.wrapS = beachTexture.wrapT = THREE.RepeatWrapping;
        beachTexture.repeat.set( 64, 64 );
        beachTexture.magFilter = THREE.NearestFilter;
        beachTexture.minFilter = THREE.LinearMipMapLinearFilter;
        beachMesh = new HeightMapMesh( beachGeometry, new THREE.MeshLambertMaterial( { map: beachTexture } ) );
        beachMesh.name = "beach";
        scene.add(beachMesh);
        //Water
        waterNormals = new THREE.ImageUtils.loadTexture( 'textures/waternormals.jpg' );
        waterNormals.wrapS = waterNormals.wrapT = THREE.RepeatWrapping;
        water = new THREE.Water( renderer, camera, scene, {
            textureWidth: 512,
            textureHeight: 512,
            waterNormals: waterNormals,
            alpha: 	1.0,
            sunDirection:  ambientLight.position.clone().normalize(),
            sunColor: 0xffffff,
            waterColor: 0x001e0f,
            distortionScale: 50.0,
        } );
        waterMesh = new THREE.Mesh(
                new THREE.PlaneBufferGeometry(parameters.width * 500, parameters.height * 500 ),
                water.material
        );
        water.opacity = 0.5;
        waterMesh.add( water );
        waterMesh.rotation.x = - Math.PI * 0.5;
        waterMesh.position.y += 70;
        scene.add( waterMesh );
        growthLowerLevel = waterMesh.position.y + 120;
        growthUpperLevel = 1241;
        // AUDIO
        var listener = new THREE.AudioListener();
        scene.add(listener);
        var audio = new THREE.Audio(listener);
        audio.load('audio/rainforest.mp3');
        //audio.autoplay = true;
        audio.setLoop(500);
        scene.add(audio);
        /////////////SKYBOX
        urlPrefix = 'textures/';
        urls = [ urlPrefix + 'sea_negx.jpg',
            urlPrefix + 'sea_neutral.jpg',
            urlPrefix + 'sea_negy.jpg',
            urlPrefix + 'sea_posy.jpg',
            urlPrefix + 'sea_negz.jpg',
            urlPrefix + 'sea_posz.jpg' ];
        textureCube = THREE.ImageUtils.loadTextureCube(urls);
        textureCube.format = THREE.RGBFormat;
        shader = THREE.ShaderLib['cube']; // init cube shader from built-in lib
        shader.uniforms['tCube'].value = textureCube; // apply textures to shader
        // create shader material
        skyBoxMaterial = new THREE.ShaderMaterial({
            fragmentShader : shader.fragmentShader,
            vertexShader : shader.vertexShader,
            uniforms : shader.uniforms,
            depthWrite : false,
            side : THREE.BackSide
        });
        mat = new THREE.MeshBasicMaterial({envMap : textureCube, side: THREE.BackSide});
        // create skybox mesh
        skyBox = new THREE.Mesh(new THREE.BoxGeometry(300000, 400000, 300000), mat);
        skyBox.doubleSided = true;
        groundMesh.add(skyBox);
        /*Irregulaert formet spline-kurve*/
        // Move this to MovementAndCamera and make it work!

        splinePoints = [];
        splinePoints.push(
                new THREE.Vector3(-6055, 363, 6823),
                new THREE.Vector3(-7410, 473, 4319),
                new THREE.Vector3(-7325, 589, 3384),
                new THREE.Vector3(-6771, 656, 1500),
                new THREE.Vector3(-5361, 819, 622),
                new THREE.Vector3(-3990, 778, -198),
                new THREE.Vector3(-2719, 653, -809),
                new THREE.Vector3(-1539, 639, -821),
                new THREE.Vector3(-1347, 662, -2049),
                new THREE.Vector3(-2146, 780, -2958),
                new THREE.Vector3(-2686, 960, -3308),
                new THREE.Vector3(-3659, 803, -4455),
                new THREE.Vector3(-4422, 910, -4871),
                new THREE.Vector3(-4180, 1090, -6131),
                new THREE.Vector3(-3307, 1362, -6256),
                new THREE.Vector3(-2458, 1626, -5823),
                new THREE.Vector3(-1613, 1953, -5827),
                new THREE.Vector3(-764, 2610, -6107),
                new THREE.Vector3(648, 3272, -7156),
                new THREE.Vector3(1861, 3723, -8148),
                new THREE.Vector3(2692, 3891, -8536),
                new THREE.Vector3(2949, 3908, -8368),
                new THREE.Vector3(3457, 3859, -7789),
                new THREE.Vector3(3831, 3707, -6979),
                new THREE.Vector3(3849, 3536, -6290),
                new THREE.Vector3(3795, 3221, -5594),
                new THREE.Vector3(3224, 2735, -4829),
                new THREE.Vector3(2737, 2335, -4547),
                new THREE.Vector3(1900, 1960, -4115),
                new THREE.Vector3(1538, 1807, -3873),
                new THREE.Vector3(756, 1335, -2933),
                new THREE.Vector3(595, 1126, -2484),
                new THREE.Vector3(419, 955, -1954),
                new THREE.Vector3(-256, 642, -978),
                new THREE.Vector3(-150, 542, -308),
                new THREE.Vector3(950, 609, 83),
                new THREE.Vector3(2206, 633, 380),
                new THREE.Vector3(2581, 639, 683),
                new THREE.Vector3(2868, 570, 1500),
                new THREE.Vector3(3084, 547, 2288),
                new THREE.Vector3(3439, 531, 2883),
                new THREE.Vector3(3836, 500, 3175),
                new THREE.Vector3(4283, 548, 3371),
                new THREE.Vector3(5490, 499, 3630)
        );

        splineCurve = new THREE.CatmullRomCurve3(splinePoints);
        splineGeometry = new THREE.Geometry();
        splineGeometry.vertices = splineCurve.getPoints(200*splinePoints.length);

        splineMaterial = new THREE.LineBasicMaterial( {color: 0x0000ff} );
        splineCurveObject = new THREE.Line(splineGeometry, splineMaterial);
        scene.add(splineCurveObject);

        camera.position.x = -6000;
        camera.position.z = 6900;
        camera.position.y = groundMesh.getHeightAtPoint(camera.position) + 350;


        //
        // Generate random positions for some number of boxes
        // Used in instancing. Better examples:
        //  * http://threejs.org/examples/#webgl_buffergeometry_instancing_dynamic
        //  * http://threejs.org/examples/#webgl_buffergeometry_instancing_billboards
        //
        // Make a buffer that can use instanced attributes
       /* instancedBoxGeom = new THREE.InstancedBufferGeometry();
        // Copy geometry from a standard box.
        instancedBoxGeom.fromGeometry(new THREE.BoxGeometry(100, 100, 100));
        numBoxes = 10;
        center = new THREE.Vector3(0,0,0);
        radius = 50 * worldHalfWidth;

        instancedMaterial = new THREE.ShaderMaterial( {
            uniforms: {
                color: { type: "c" , value: new THREE.Color(Math.random(), Math.random(), Math.random()) }
            },
            vertexShader: document.getElementById("instanced-vshader").textContent,
            fragmentShader: document.getElementById("fshader").textContent
        } );
        instancedBox = new THREE.Mesh(instancedBoxGeom, instancedMaterial);
        instancedBox.name = "instancedBox";
        groundMesh.add(instancedBox);*/

        GenerateObjects.billboard();

        GenerateObjects.palms3D();

        GenerateObjects.plants3D();

        GenerateObjects.ship();

        window.addEventListener( 'resize', onWindowResize, false );
    }
    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize( window.innerWidth, window.innerHeight );
        controls.handleResize();
    }
    // Seen both animate and render functions done in a different way thight might be better for us
    // Should change it
    function animate() {
        requestAnimationFrame( animate );
        angle +=0.00001;
        //sunLight.update(angle); 
        water.material.uniforms.time.value += angle;
        lensFlare.position.set(sunLight.object3d.position.x, sunLight.object3d.position.y, sunLight.object3d.position.z);
        lavaMesh.rotation.z += 0.01;
        x = camera.position.x;
        y = camera.position.y;
        z = camera.position.z;
        if((x2 === x) && (y2 === y) && (z2 === z) ) {
            flag = false;
        } else {
            flag = true;
        }
        if(flag) {
            console.log(Math.round(x), Math.round(y), Math.round(z) );
        }
        render();
        stats.update();
    }
    function render() {
        //        renderer.clear(); //nullstiller alle fargebuffere etc 
        controls.update(clock.getDelta());
        //        controls.update(); 
        x2 = x;
        y2 = y;
        z2 = z;
        water.render();
        renderer.render( scene, camera );
    }
    // Do we use onProgress and onError
    // Do we need it
    function onProgress( xhr ) {
        if ( xhr.lengthComputable ) {
            var percentComplete = xhr.loaded / xhr.total * 100;
            console.log( Math.round(percentComplete, 2) + '% downloaded' );
        }
    }
    function onError( xhr ) {}
</script>

<img src="textures/groundMap.jpeg" id="groundmap" hidden/>
<img src="textures/mountainMap.jpeg" id="mountainmap" hidden/>
<img src="textures/beachMap.jpeg" id="beachmap" hidden/>

</body>
</html>