<!DOCTYPE html>
<html lang="en">
<head>
    <title>Jungel</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link rel="stylesheet" href="style.css">
</head>

<body>
<div id="container"><br /><br /><br /><br /><br />Generating world...</div>
<div id="info"><a href="http://threejs.org" target="_blank">three.js</a> - webgl terrain demo<br />(left click: forward, right click: backward)</div>

<script src="bower_components/three.js/build/three.min.js"></script>
<script src="bower_components/three.js/build/three.js"></script>
<script src="bower_components/three.js/examples/js/loaders/OBJLoader.js"></script>
<script src="bower_components/three.js/examples/js/loaders/DDSLoader.js"></script>
<script src="bower_components/three.js/examples/js/loaders/MTLLoader.js"></script>
<script src="bower_components/three.js/examples/js/loaders/OBJMTLLoader.js"></script>
<script src="bower_components/three.js/examples/js/controls/FirstPersonControls.js"></script>
<script src="bower_components/three.js/examples/js/controls/OrbitControls.js"></script>
<script src="bower_components/three.js/examples/js/ImprovedNoise.js"></script>
<script src="bower_components/three.js/examples/js/Detector.js"></script>
<script src="bower_components/three.js/examples/js/libs/stats.min.js"></script>
<script src="bower_components/three.js/examples/js/libs/dat.gui.min.js"></script>
<script src="bower_components/three.js/examples/js/objects/ShadowMesh.js"></script>
<script src="bower_components/three.js/examples/js/postprocessing/BloomPass.js"></script>

<script src="src/HeightMapGeometry.js"></script>
<script src="src/HeightMapMesh.js"></script>
<script src="src/DayNightCycle.js"></script>
<script src="src/GenerateMap.js"></script>
<script src="src/GenerateObjects.js"></script>
<script src="src/GenerateTexture.js"></script>
<script src="src/Mirror.js"></script> 
<script src="src/Water.js"></script>
<script src="src/SoundFX.js"></script>
<script src="src/MovementAndCamera.js"></script>

<script id="vertex-shader" type="x-shader/x-vertex">
    // Other attributes and uniforms are supposed to be filled in by Three.js
    // To avoid it being filled in automatically, use RawShaderMaterial
    attribute vec3 translate;
    varying vec2 vUV;
    void main() {
        <!--vec4 mvPosition = modelViewMatrix * vec4( translate + position, 1.0 );-->
        vec4 pos = vec4(position, 1.0);
        vUV = uv;
        gl_Position = projectionMatrix * modelViewMatrix * pos;
    }
</script>

<script id="fragment-shader" type="x-shader/x-fragment">
    // Other attributes and uniforms are supposed to be filled in by Three.js
    // To avoid it being filled in automatically, use RawShaderMaterial
    uniform sampler2D texture;
    varying vec2 vUV;
    <!--uniform vec3 color;-->
    void main() {
        vec4 sample = texture2D(texture, vUV);
        gl_FragColor = vec4(sample.xyz, sample.w);
    }
</script>

<script>
    "use strict";

    var container, stats;
    var camera, controls, scene, renderer, composer;
    var x, y, z;
    var x2, y2, z2;
    var flag = false;
    // Probably GenerateMap
    var groundData, groundMesh, groundTexture, groundMapImage, groundGeometry,
            mountainData, mountainMesh, mountainTexture, mountainMapImage, mountainGeometry,
            lavaMesh, lavaTexture,lavaGeometry,
            beachData, beachMesh, beachTexture, beachMapImage, beachGeometry;
    var water;
    var waterMesh;
    var frameTime;
    var angle = 0.0;
    var randx;
    var randy;
    var randz;
    var bbox;
    var manager;
    var loader;
    var objectMaterialLoader;
    var objectLoader;

    var spriteModels;
    var spriteGeom;
    var spriteTexture;
    var palmSprite;
    var myPalm;
    var growthLowerLevel;
    var growthUpperLevel;
    var waterNormals;
    var count;
    var boxGeom;
    var growthPosition1;
    var growthPosition2;
    var numBoxes;
    var center;
    var radius;
    var instancedMaterial;
    var instancedBox;
    var instancedBoxGeom;

    var worldWidth, worldHeight ,
            worldHalfWidth, worldHalfHeight;
    var clock = new THREE.Clock();

    window.onload = function() {
        init();
        animate();
    };

    var parameters = {
        width: 2000,
        height: 2000,
        widthSegments: 250,
        heightSegments: 250,
        depth: 1500,
        param: 4,
        filterparam: 1
    };

    function init() {
        container = document.getElementById('container');
        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 300000);
        camera.name = 'camera';
        scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0XFFFFFF, 0.0000085);
        controls = new THREE.FirstPersonControls(camera);
        controls.movementSpeed = 1500;
        controls.lookSpeed = 0.1;
        manager = new THREE.LoadingManager();
        manager.onProgress = function ( item, loaded, total ) {
            console.log( item, loaded, total );
        };
        loader = new THREE.ImageLoader( manager );

        ///////////////////////////////////////////////////////
        //                      Renderer                    //
        /////////////////////////////////////////////////////
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true } );
        renderer.setClearColor( 0xbfd1e5 );
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( window.innerWidth, window.innerHeight );
        renderer.autoClear = false;
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.shadowDarkness = 1.0;
        container.innerHTML = "";
        container.appendChild( renderer.domElement );
        stats = new Stats();
        stats.domElement.style.position = 'absolute';
        stats.domElement.style.top = '0px';
        container.appendChild( stats.domElement );

        ///////////////////////////////////////////////////////
        //                      Lights                      //
        /////////////////////////////////////////////////////
        // Needed for materials using phong shading
        // This needs to be done differently
        var ambientLight = new THREE.AmbientLight(0xffffff);
        ambientLight.name = 'ambientLight';
        scene.add(ambientLight);
        var dayNightCycle = new DayNightCycle();
        dayNightCycle.sunLight();
        // Height map generation/extraction
        // Needs to move to GenerateMap
        //
        ///////BLOOOM
        /*        var renderModel = new THREE.RenderPass( scene, camera );
         var effectBloom = new THREE.BloomPass( 1.25 );
         var effectFilm = new THREE.FilmPass( 0.35, 0.95, 2048, false );
         effectFilm.renderToScreen = true;
         composer = new THREE.EffectComposer( renderer );
         composer.addPass( renderModel );
         composer.addPass( effectBloom );
         composer.addPass( effectFilm );*/
        ////
        ///////////////////////////////////////////////////////
        //                      Meshes                      //
        /////////////////////////////////////////////////////
        //
        // This need to move to GenerateMap
        //
        //Ground
        var generateMap = new GenerateMap();
        groundMapImage = document.getElementById('groundmap');
        groundData = generateMap.getPixelValues(groundMapImage, 'r');
        worldWidth = groundMapImage.width;
        worldHeight = groundMapImage.height;
        worldHalfWidth = Math.floor(worldWidth / 2);
        worldHalfHeight = Math.floor(worldHeight / 2);
        groundGeometry = new HeightMapBufferGeometry(groundData, worldWidth, worldHeight);
        groundGeometry.scale(50*worldWidth, 4500, 50*worldHeight);
        groundTexture = THREE.ImageUtils.loadTexture( "textures/groundDirtTexture.jpg" );
        groundTexture.wrapS = groundTexture.wrapT = THREE.RepeatWrapping;
        groundTexture.repeat.set( 256, 256 );
        groundTexture.magFilter = THREE.NearestFilter;
        groundTexture.minFilter = THREE.LinearMipMapLinearFilter;
        groundMesh = new HeightMapMesh( groundGeometry,  new THREE.MeshLambertMaterial( { map: groundTexture } ));
        groundMesh.name = "terrain";
        groundMesh.receiveShadows = true;
        scene.add( groundMesh );

        //Mountain
        mountainMapImage = document.getElementById('mountainmap');
        mountainData = generateMap.getPixelValues(mountainMapImage, 'r');
        mountainGeometry = new HeightMapBufferGeometry(mountainData, worldWidth, worldHeight);
        mountainGeometry.scale(50*worldWidth, 4500, 50*worldHeight);
        mountainTexture = THREE.ImageUtils.loadTexture( "textures/mountainTexture.jpg" );
        mountainTexture.wrapS = mountainTexture.wrapT = THREE.RepeatWrapping;
        mountainTexture.repeat.set( 64, 64 );
        mountainTexture.magFilter = THREE.NearestFilter;
        mountainTexture.minFilter = THREE.LinearMipMapLinearFilter;
        mountainMesh = new HeightMapMesh( mountainGeometry, new THREE.MeshLambertMaterial( { map: mountainTexture } ) );
        mountainMesh.name = "mountain";
        groundMesh.add(mountainMesh);

        //Lava
        lavaTexture = THREE.ImageUtils.loadTexture( "textures/lavaTexture.jpg" );
        lavaTexture.wrapS = lavaTexture.wrapT = THREE.RepeatWrapping;
        /*        lavaTexture.repeat.set( 64, 64 );*/
        lavaGeometry = new THREE.CircleGeometry(700, 1000);
        lavaMesh = new THREE.Mesh(lavaGeometry,new THREE.MeshLambertMaterial({side: THREE.DoubleSide, map: lavaTexture}));
        lavaMesh.position.set(2457, 3118, -7502);
        lavaMesh.rotation.x = Math.PI /2;
        scene.add(lavaMesh);

        //Beach
        beachMapImage = document.getElementById('beachmap');
        beachData = generateMap.getPixelValues(beachMapImage, 'r');
        beachGeometry = new HeightMapBufferGeometry(beachData, worldWidth, worldHeight);
        beachGeometry.scale(50*worldWidth, 4500, 50*worldHeight);
        beachTexture = THREE.ImageUtils.loadTexture( "textures/beachTexture.jpg" );
        beachTexture.wrapS = beachTexture.wrapT = THREE.RepeatWrapping;
        beachTexture.repeat.set( 64, 64 );
        beachTexture.magFilter = THREE.NearestFilter;
        beachTexture.minFilter = THREE.LinearMipMapLinearFilter;
        beachMesh = new HeightMapMesh( beachGeometry, new THREE.MeshLambertMaterial( { map: beachTexture } ) );
        beachMesh.name = "beach";
        scene.add(beachMesh);
        //Water
        waterNormals = new THREE.ImageUtils.loadTexture( 'textures/waternormals.jpg' );
        waterNormals.wrapS = waterNormals.wrapT = THREE.RepeatWrapping;
        water = new THREE.Water( renderer, camera, scene, {
            textureWidth: 512,
            textureHeight: 512,
            waterNormals: waterNormals,
            alpha: 	1.0,
            sunDirection:  ambientLight.position.clone().normalize(),
            sunColor: 0xffffff,
            waterColor: 0x001e0f,
            distortionScale: 50.0,
        } );
        waterMesh = new THREE.Mesh(
                new THREE.PlaneBufferGeometry(parameters.width * 500, parameters.height * 500 ),
                water.material
        );
        water.opacity = 0.5;
        waterMesh.add( water );
        waterMesh.rotation.x = - Math.PI * 0.5;
        waterMesh.position.y += 70;
        scene.add( waterMesh );
        growthLowerLevel = waterMesh.position.y + 120;
        growthUpperLevel = 1241;

        camera.position.x = -6000;
        camera.position.z = 6900;
        camera.position.y = groundMesh.getHeightAtPoint(camera.position) + 350;


        //
        // Generate random positions for some number of boxes
        // Used in instancing. Better examples:
        //  * http://threejs.org/examples/#webgl_buffergeometry_instancing_dynamic
        //  * http://threejs.org/examples/#webgl_buffergeometry_instancing_billboards
        //
        // Make a buffer that can use instanced attributes
       /* instancedBoxGeom = new THREE.InstancedBufferGeometry();
        // Copy geometry from a standard box.
        instancedBoxGeom.fromGeometry(new THREE.BoxGeometry(100, 100, 100));
        numBoxes = 10;
        center = new THREE.Vector3(0,0,0);
        radius = 50 * worldHalfWidth;

        instancedMaterial = new THREE.ShaderMaterial( {
            uniforms: {
                color: { type: "c" , value: new THREE.Color(Math.random(), Math.random(), Math.random()) }
            },
            vertexShader: document.getElementById("instanced-vshader").textContent,
            fragmentShader: document.getElementById("fshader").textContent
        } );
        instancedBox = new THREE.Mesh(instancedBoxGeom, instancedMaterial);
        instancedBox.name = "instancedBox";
        groundMesh.add(instancedBox);*/

        ///////////////////////////
        //   Correct methods    //
        /////////////////////////

        GenerateObjects.billboard();

        GenerateObjects.palms3D();

        GenerateObjects.plants3D();

        GenerateObjects.ship();

        var movementAndCamera = new MovementAndCamera();
        movementAndCamera.createSpline();

        var soundFX = new SoundFX();

        soundFX.jungleSounds();

        dayNightCycle.skybox();

        ///////////////////////////////
        //    End correct methods   //
        /////////////////////////////
        window.addEventListener( 'resize', onWindowResize, false );
    }
    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize( window.innerWidth, window.innerHeight );
        controls.handleResize();
    }
    // Seen both animate and render functions done in a different way thight might be better for us
    // Should change it
    function animate() {
        requestAnimationFrame( animate );
        angle +=0.00001;
        //sunLight.update(angle); 
        water.material.uniforms.time.value += angle;
        //lensFlare.position.set(sunLight.object3d.position.x, sunLight.object3d.position.y, sunLight.object3d.position.z);
        lavaMesh.rotation.z += 0.01;
        x = camera.position.x;
        y = camera.position.y;
        z = camera.position.z;
        if((x2 === x) && (y2 === y) && (z2 === z) ) {
            flag = false;
        } else {
            flag = true;
        }
        if(flag) {
            console.log(Math.round(x), Math.round(y), Math.round(z) );
        }
        render();
        stats.update();
    }
    function render() {
        //        renderer.clear(); //nullstiller alle fargebuffere etc 
        controls.update(clock.getDelta());
        x2 = x;
        y2 = y;
        z2 = z;
        water.render();
        renderer.render( scene, camera );
    }
    // Do we use onProgress and onError
    // Do we need it
    function onProgress( xhr ) {
        if ( xhr.lengthComputable ) {
            var percentComplete = xhr.loaded / xhr.total * 100;
            console.log( Math.round(percentComplete, 2) + '% downloaded' );
        }
    }
    function onError( xhr ) {}

</script>

<img src="textures/groundMap.jpeg" id="groundmap" hidden/>
<img src="textures/mountainmap.jpeg" id="mountainmap" hidden/>
<img src="textures/lavamap.jpeg" id="lavamap" hidden/>
<img src="textures/beachMap.jpeg" id="beachmap" hidden/>

</body>
</html>