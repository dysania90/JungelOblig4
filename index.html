<!DOCTYPE html>
<html lang="en">
<head>
    <title>Jungel</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link rel="stylesheet" href="style.css">
</head>
<body>

<div id="container"><br /><br /><br /><br /><br />Generating world...</div>
<div id="info"><a href="http://threejs.org" target="_blank">three.js</a> - webgl terrain demo<br />(left click: forward, right click: backward)</div>

<script src="bower_components/three.js/build/three.min.js"></script>
<script src="bower_components/three.js/build/three.js"></script>
<script src="bower_components/three.js/examples/js/loaders/OBJLoader.js"></script>

<script src="bower_components/three.js/examples/js/loaders/DDSLoader.js"></script>
<script src="bower_components/three.js/examples/js/loaders/MTLLoader.js"></script>
<script src="bower_components/three.js/examples/js/loaders/OBJMTLLoader.js"></script>

<script src="bower_components/three.js/examples/js/controls/FirstPersonControls.js"></script>

<script src="bower_components/three.js/examples/js/ImprovedNoise.js"></script>
<script src="bower_components/three.js/examples/js/Detector.js"></script>
<script src="bower_components/three.js/examples/js/libs/stats.min.js"></script>

<script src="src/HeightMapGeometry.js"></script>
<script src="src/HeightMapMesh.js"></script>
<script src="src/DayNightCycle.js"></script>
<script src="src/GenerateMap.js"></script>
<script src="src/GenerateObjects.js"></script>
<script src="src/GenerateTexture.js"></script>


<script id="instanced-vshader" type="x-shader/x-vertex">
		// Other attributes and uniforms are supposed to be filled in by Three.js
		// To avoid it being filled in automatically, use RawShaderMaterial

        // Instanced attribute, updated only when a new instance is drawn (ie. when all vertices have been drawn and
        // we're going to draw a slightly different one.
		attribute vec3 translate;

		varying vec2 vUv;

		void main() {

			vec4 mvPosition = modelViewMatrix * vec4( translate + position, 1.0 );

			vUv = uv;

			gl_Position = projectionMatrix * mvPosition;

		}

</script>

<script id="fshader" type="x-shader/x-fragment">
        // Other attributes and uniforms are supposed to be filled in by Three.js
		// To avoid it being filled in automatically, use RawShaderMaterial

           uniform vec3 color;

		void main() {

			gl_FragColor = vec4(color, 1.0);

		}
</script>

<script>
    // What is this, do we need it?
    if ( ! Detector.webgl ) {
        Detector.addGetWebGLMessage();
        document.getElementById( 'container' ).innerHTML = "";
    }

    var container, stats;

    var camera, controls, scene, renderer;

    // Probably GenerateMap
    var terrainData, terrainMesh, terrainTexture, dirtroadMesh, waterMesh, waterData;

    // WAAAAAY too many var stuff here. Move it where it belongs (GenerateTexture for the most part)
    /*Ground texture*/
    var groundtexture = THREE.ImageUtils.loadTexture( "textures/junglefloortexture.jpg" );
    groundtexture.wrapS = THREE.RepeatWrapping;
    groundtexture.wrapT = THREE.RepeatWrapping;
    groundtexture.repeat.set( 256, 256 );

    /*Dirt road texture*/
    var dirtroadtexture = THREE.ImageUtils.loadTexture("textures/dirtroadtexture.jpg");
    dirtroadtexture.wrapS = THREE.RepeatWrapping;
    dirtroadtexture.wrapT = THREE.RepeatWrapping;
    dirtroadtexture.repeat.set( 64, 64 );

    /*Water texture*/
    var watertexture = THREE.ImageUtils.loadTexture("textures/watertexture.jpg");
    watertexture.wrapS = THREE.RepeatWrapping;
    watertexture.wrapT = THREE.RepeatWrapping;
    watertexture.repeat.set( 64, 64 );

    var worldWidth = 512, worldDepth = 512,
            worldHalfWidth = worldWidth / 2, worldHalfDepth = worldDepth / 2;

    var clock = new THREE.Clock();

    window.onload = function() {
        init();
        animate();
    };

    function init() {
        "use strict";

        container = document.getElementById('container');

        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 20000);
        camera.name = 'camera';

        scene = new THREE.Scene();

        controls = new THREE.FirstPersonControls(camera);
        controls.movementSpeed = 1000;
        controls.lookSpeed = 0.1;

        ///////////////////////////////////////////////////////
        //                      Lights                      //
        /////////////////////////////////////////////////////

        // Needed for materials using phong shading
        // This needs to be done differently
        var ambientLight = new THREE.AmbientLight(0xffffff);
        ambientLight.name = 'ambientLight';
        scene.add(ambientLight);

        var sunLight = new DayNightCycle.sunLight();
        scene.add( sunLight.object3d );

        //scene.add(new THREE.DirectionalLightHelper(sunLight, 100));

        //
        // Height map generation/extraction
        // Needs to move to GenerateMap
        //

        var useRandomHeightMap = false;

        if (useRandomHeightMap) {
            terrainData = GenerateMap.generateHeight( worldWidth, worldDepth );
        } else {
            var heightMapImage = document.getElementById('heightmap');
            terrainData = GenerateMap.getPixelValues(heightMapImage, 'r');
            worldWidth = heightMapImage.width;
            worldDepth = heightMapImage.height;
            worldHalfWidth = Math.floor(worldWidth / 2);
            worldHalfDepth = Math.floor(worldDepth / 2);
        }
        var waterMapImage = document.getElementById('watermap');
        waterData = GenerateMap.getPixelValues(waterMapImage, 'r');

        // Not required to use the generated texture
        // Where do we generate textures? Seems to be spread out. Needs to clump it together and
        // move to own file (GenerateTexture)
        terrainTexture = new THREE.CanvasTexture( GenerateTexture.generateTexture( terrainData, worldWidth, worldDepth ) );
        terrainTexture.wrapS = THREE.ClampToEdgeWrapping;
        terrainTexture.wrapT = THREE.ClampToEdgeWrapping;

        //
        // Generate terrain geometry and mesh
        // This need to move to GenerateMap
        //

        var heightMapGeometry = new HeightMapBufferGeometry(terrainData, worldWidth, worldDepth);
        // We scale the geometry to avoid scaling the node, since scales propagate.
        heightMapGeometry.scale(50*worldWidth, 4500, 50*worldDepth);

        var dirtroadGeometry = new HeightMapBufferGeometry(terrainData, worldWidth, worldDepth);
        dirtroadGeometry.scale(40*worldWidth, 1000, 40*worldDepth);


        terrainMesh = new HeightMapMesh( heightMapGeometry, new THREE.MeshLambertMaterial( { map: groundtexture } ) );
        terrainMesh.name = "terrain";

        terrainMesh.castShadow = true;
        terrainMesh.receiveShadows = true;

        scene.add( terrainMesh );

        var waterGeometry = new HeightMapBufferGeometry(waterData, worldWidth, worldDepth);
        waterGeometry.scale(50*worldWidth, 1000, 50*worldDepth);

        waterMesh = new HeightMapMesh(waterGeometry, new THREE.MeshLambertMaterial({ map: watertexture}));
        waterMesh.name = "water";

        waterMesh.recieveShadows = true;

        scene.add(waterMesh);
        waterMesh.position.y -= 976;
        var waterLevel = waterMesh.position.y + 976;
/*        for(var i = 0; i <terrainData.length; i++) {
            if(terrainData[])
        }*/
/*        dirtroadMesh = new HeightMapMesh( dirtroadGeometry, new THREE.MeshBasicMaterial( { map: dirtroadtexture } ) );
        dirtroadMesh.name = "dirtroad";
        scene.add(dirtroadMesh);*/

        /*Irregulaert formet spline-kurve*/
        // Move this to MovementAndCamera and make it work!
        var randomPoints = [];

        /*
        var num = 10;

        for(var i = 0; i < num; i++) {
            randomPoints.push(new THREE.Vector3(Math.random() * 4000 - 1500, Math.random()
                    * 3000 - 1500, Math.random() * 3000 - 1500));
        }

        for(var i = 0; i < num; i++) {
            randomPoints[i].y = terrainMesh.getHeightAtPoint(randomPoints[i]) + 1;
        }

        var negate = -2;
         */

        var count = 1000;
        /*
        for(var i = 0; i < count; i++) {
            randomPoints.push(new THREE.Vector3(-count+(i*2), 1000, count-(i*7)));
        }*/
        randomPoints.push(
                new THREE.Vector3(-1000, 1000, 1000),
                new THREE.Vector3(-800, 1000, 900),
                new THREE.Vector3(-400, 1000, 800),
                new THREE.Vector3(200, 1000, 700),
                new THREE.Vector3(400, 1000, 400),
                new THREE.Vector3(600, 1000, -200),
                new THREE.Vector3(500, 1000, -600),
                new THREE.Vector3(900, 1000, - 1400),
                new THREE.Vector3(1300, 1000, -1400),
                new THREE.Vector3(1600, 1000, -1000),
        new THREE.Vector3(1600, 1000, -900),
        new THREE.Vector3(1500, 1000, -800),
        new THREE.Vector3(1300, 1000, -700),
        new THREE.Vector3(900, 1000, -700)
        );

        for(var i = 0; i < 14; i++) {
            randomPoints[i].y = terrainMesh.getHeightAtPoint(randomPoints[i]);

           /* if(randomPoints[i].y < terrainMesh.getHeightAtPoint(randomPoints[i])) {
             randomPoints[i].y += 10;
             }*/
        }

        var splineCurve = new THREE.CatmullRomCurve3(randomPoints);

        var geometry = new THREE.Geometry();
        geometry.vertices = splineCurve.getPoints(2000);

        /*  for(var i = 0; i < 1000; i++) {
            geometry.vertices[i].y = terrainMesh.getHeightAtPoint(geometry.vertices[i]);
        }   */

        var irregularMaterial = new THREE.LineBasicMaterial( {color: 0x0000ff} );

        var splineCurveObject = new THREE.Line(geometry, irregularMaterial);
        scene.add(splineCurveObject);

        splineCurveObject.position.set(1000,100,1000);

        // End move to MovementAndCamera

        //
        // Some other updates
        // What updates, when does these updates end??
        //


        //Old camera position, approximately on the middle of the map.
/*        camera.position.y = terrainMesh.getHeightAtPoint(camera.position) + 500;*/

        //New camera position, on the "southern" side of the map
        camera.position.x = -10000;
        camera.position.z = 3000;
        camera.position.y = terrainMesh.getHeightAtPoint(camera.position) + 500;

        var boxGeom = new THREE.BoxGeometry(100, 100, 100);
        var customBox = new THREE.Mesh(boxGeom);

        terrainMesh.add(customBox);
        customBox.position.setY(terrainMesh.getHeightAtPoint(customBox.position));

        //
        // Generate random positions for some number of boxes
        // Used in instancing. Better examples:
        //  * http://threejs.org/examples/#webgl_buffergeometry_instancing_dynamic
        //  * http://threejs.org/examples/#webgl_buffergeometry_instancing_billboards
        //

        // Make a buffer that can use instanced attributes
        var instancedBoxGeom = new THREE.InstancedBufferGeometry();
        // Copy geometry from a standard box.
        instancedBoxGeom.fromGeometry(new THREE.BoxGeometry(100, 100, 100));

        var numBoxes = 10;
        var center = new THREE.Vector3(0,0,0);
        var radius = 50 * worldHalfWidth;

        var texture = new THREE.Texture();
        var texture2 = new THREE.Texture();

        // Guessing the start of generating objects is here, make a function and move it
        var manager = new THREE.LoadingManager();
        manager.onProgress = function ( item, loaded, total ) {

            console.log( item, loaded, total );
        };

        var loader = new THREE.ImageLoader( manager );
        loader.load( 'resources/textures/samples/terrain/tree/palm_tree/diffuse.png', function ( image ) {
            texture.image = image;
            texture.needsUpdate = true;
        } );

        var objectLoader = new THREE.OBJLoader( manager );

        var models = ['models/palmTrees/palm_straight.obj', 'models/palmTrees/palm_bend.obj',
            'models/palmTrees/palm_dual.obj', 'models/palmTrees/palm_trio.obj',
            'resources/mesh/samples/terrain/plants/tropical_plant2/tropical_plant.obj' ];

        var j = 0;
        for(var i = 0; i < numBoxes; i++) {

            if(j === 4) {
                j = 0;
            }
            objectLoader.load( models[j], function ( object ) {

                object.traverse( function ( child ) {

                    if ( child instanceof THREE.Mesh ) {

                        child.material.map = texture;

                    }

                } );

                var bbox = new THREE.Box3().setFromObject(object);
                var randx = radius * (2*Math.random() - 1);
                var randy = radius * (2*Math.random() - 1);
                var randz = radius * (2*Math.random() - 1);

                object.position.set(randx, randy, randz);
                object.position.y = terrainMesh.getHeightAtPoint(object.position);
                /*object.position.y -= bbox.min.y;*/

                object.name = "Palm";

                if(object.position.y > (waterLevel + 70)) {
                    terrainMesh.add(object);
                }


            }, onProgress, onError );
            j++;
        }

        loader.load( 'resources/textures/samples/terrain/plants/tropical_plant2/diffuse.png', function ( image ) {

            texture2.image = image;
            texture2.needsUpdate = true;

        } );

        for(var i = 0; i < numBoxes; i++) {

            objectLoader.load(models[4], function (object) {

                object.traverse(function (child) {

                    if (child instanceof THREE.Mesh) {

                        child.material.map = texture2;

                    }

                });

                var bbox = new THREE.Box3().setFromObject(object);
                var randx = radius * (2 * Math.random() - 1);
                var randy = radius * (2 * Math.random() - 1);
                var randz = radius * (2 * Math.random() - 1);

                object.position.set(randx, randy, randz);
                object.position.y = terrainMesh.getHeightAtPoint(object.position);
                /*object.position.y -= bbox.min.y;*/

                object.name = "Tropical plant";

                if (object.position.y > (waterLevel + 70)) {
                    terrainMesh.add(object);
                }


            }, onProgress, onError);
            j++;
        }

        var instancedMaterial = new THREE.ShaderMaterial( {
            uniforms: {
                color: { type: "c" , value: new THREE.Color(Math.random(), Math.random(), Math.random()) }
            },
            vertexShader: document.getElementById("instanced-vshader").textContent,
            fragmentShader: document.getElementById("fshader").textContent
        } );

        var instancedBox = new THREE.Mesh(instancedBoxGeom, instancedMaterial);
        instancedBox.name = "instancedBox";

        //terrainMesh.add(instancedBox);

        //
        // Set up renderer
        // Seen this done better, cleaner. We need to do this
        //

        renderer = new THREE.WebGLRenderer();
        renderer.setClearColor( 0xbfd1e5 );
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( window.innerWidth, window.innerHeight );

        container.innerHTML = "";

        container.appendChild( renderer.domElement );

        stats = new Stats();
        stats.domElement.style.position = 'absolute';
        stats.domElement.style.top = '0px';
        container.appendChild( stats.domElement );

        window.addEventListener( 'resize', onWindowResize, false );

    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize( window.innerWidth, window.innerHeight );
        controls.handleResize();
    }

    // Seen both animate and render functions done in a different way thight might be better for us
    // Should change it
    function animate() {
        requestAnimationFrame( animate );
        render();
        stats.update();
    }

    function render() {
        controls.update( clock.getDelta() );
        renderer.render( scene, camera );
    }

    // Do we use onProgress and onError
    // Do we need it
    function onProgress( xhr ) {
        if ( xhr.lengthComputable ) {
            var percentComplete = xhr.loaded / xhr.total * 100;
            console.log( Math.round(percentComplete, 2) + '% downloaded' );
        }
    }

    function onError( xhr ) {}

</script>

<img src="textures/heightmapIsland4.jpeg" id="heightmap" hidden/>
<img src="textures/junglefloortexture.jpg" id="groundtexture" hidden/>
<img src="textures/dirtroadtexture.jpg" id="dirtroadtexture" hidden/>
<img src="textures/watertexture.jpg" id="watertexture" hidden/>
<img src="textures/watermap.jpg" id="watermap" hidden/>

</body>
</html>